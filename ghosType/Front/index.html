<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOSTYPE BLE í…ŒìŠ¤íŠ¸ (í•œê¸€ ì§€ì›)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 700px;
            text-align: center;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status.disconnected { background: #fee; color: #c33; }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.connected { background: #d4edda; color: #155724; }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .typing-speed-control {
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .typing-speed-control label {
            color: #495057;
            font-weight: 500;
        }

        .typing-speed-control select {
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            color: #333;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .typing-speed-control select:hover {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .typing-speed-control select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2);
        }

        .message-area {
            margin: 20px 0;
        }

        input[type="text"], textarea {
            width: 85%;
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1.1em;
            margin-right: 10px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-btn {
            padding: 12px 20px;
            font-size: 0.9em;
        }

        .conversion-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            text-align: left;
            min-height: 60px;
            transition: all 0.3s ease;
        }

        .conversion-preview.korean {
            border-color: #28a745;
            background: #d4edda;
        }

        .conversion-preview.english {
            border-color: #007bff;
            background: #d1ecf1;
        }

        .conversion-preview.mixed {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .protocol-info {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        /* Log Modal Styles */
        .log-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }

        .log-modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            animation: modalSlide 0.3s ease-out;
        }

        .log-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .log-modal-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .log-modal-close {
            background: #dc3545;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .log-modal-close:hover {
            background: #c82333;
            transform: rotate(90deg);
        }

        .log-modal-body {
            flex: 1;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .view-logs-btn {
            background: linear-gradient(45deg, #17a2b8, #20c997);
            padding: 10px 20px;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .view-logs-btn:hover {
            background: linear-gradient(45deg, #138496, #1aa379);
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
        }

        .log-info { background: #d1ecf1; color: #0c5460; }
        .log-success { background: #d4edda; color: #155724; }
        .log-error { background: #f8d7da; color: #721c24; }
        .log-data { background: #fff3cd; color: #856404; }

        .test-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .test-btn {
            padding: 8px 16px;
            font-size: 0.9em;
            border-radius: 20px;
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .test-btn:hover {
            background: linear-gradient(45deg, #218838, #1ea383);
        }

        .korean-test-btn {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
        }

        .korean-test-btn:hover {
            background: linear-gradient(45deg, #c82333, #d91a72);
        }

        .special-btn {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
        }

        .special-btn:hover {
            background: linear-gradient(45deg, #5a2d91, #d91a72);
        }


        /* ì¹´ìš´íŠ¸ë‹¤ìš´ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .countdown-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .countdown-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: modalSlide 0.3s ease-out;
        }

        .countdown-instruction {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .countdown-instruction p {
            margin: 10px 0;
            color: #555;
            line-height: 1.5;
        }

        .countdown-instruction strong {
            color: #333;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .countdown-number {
            font-size: 4em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
            text-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .countdown-message {
            font-size: 1.2em;
            color: #333;
            margin: 20px 0;
        }

        .countdown-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            color: #495057;
            word-break: break-all;
            text-align: left;
        }

        .cancel-btn {
            background: #dc3545;
            margin-top: 20px;
        }

        .cancel-btn:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .info-box {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: left;
        }

        .info-box h4 {
            color: #004085;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .language-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 8px;
        }

        .lang-korean {
            background: #d4edda;
            color: #155724;
        }

        .lang-english {
            background: #d1ecf1;
            color: #0c5460;
        }

        .lang-mixed {
            background: #fff3cd;
            color: #856404;
        }

        .lang-special {
            background: #e2e3e5;
            color: #383d41;
        }

        /* Message Input Modal Styles */
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            backdrop-filter: blur(5px);
        }

        .message-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            animation: modalSlide 0.3s ease-out;
        }

        .message-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .message-modal-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
        }

        .message-modal-textarea {
            width: 100%;
            min-height: 300px;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 15px;
            font-size: 1.2em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            margin-bottom: 20px;
        }

        .message-modal-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .message-modal-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            max-height: 200px;
            overflow-y: auto;
        }

        .message-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .done-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .done-btn:hover {
            background: linear-gradient(45deg, #218838, #1aa383);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                width: 95%;
                padding: 20px;
            }

            .logo {
                font-size: 2em;
            }

            .subtitle {
                font-size: 1em;
            }

            button {
                padding: 12px 20px;
                font-size: 1em;
                min-width: 100px;
            }

            input[type="text"] {
                width: 100%;
                margin-bottom: 10px;
                margin-right: 0;
            }

            .message-area {
                display: flex;
                flex-direction: column;
            }

            .send-btn {
                width: 100%;
            }

            .test-buttons {
                gap: 5px;
            }

            .test-btn, .korean-test-btn, .special-btn {
                padding: 6px 12px;
                font-size: 0.8em;
            }

            .message-modal-content {
                padding: 20px;
                width: 95%;
            }

            .message-modal-textarea {
                min-height: 200px;
                font-size: 1em;
            }

            .log-modal-content {
                padding: 20px;
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div class="container" role="main">
        <div class="logo">ğŸ‘» GHOSTYPE</div>
        <div class="subtitle">BLE í‚¤ë³´ë“œ ì›¹ í…ŒìŠ¤íŠ¸ (í•œê¸€ ì§€ì›)</div>

        <div id="status" class="status disconnected" role="status" aria-live="polite">
            ğŸ”´ ì—°ê²° ì•ˆë¨ - ì—°ê²° ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”
        </div>

        <div class="controls" role="group" aria-label="ì—°ê²° ì»¨íŠ¸ë¡¤">
            <button id="connectBtn" onclick="connectDevice()" aria-label="BLE ë””ë°”ì´ìŠ¤ ì—°ê²°">ğŸ”— ì—°ê²°</button>
            <button id="disconnectBtn" onclick="disconnectDevice()" disabled aria-label="BLE ë””ë°”ì´ìŠ¤ ì—°ê²° í•´ì œ">âŒ ì—°ê²° í•´ì œ</button>
            <button class="view-logs-btn" onclick="toggleLogModal()" aria-label="ì—°ê²° ë¡œê·¸ ë³´ê¸°">ğŸ“‹ View Logs</button>
            <button class="view-logs-btn" onclick="openHistoryModal()" aria-label="ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ë³´ê¸°">ğŸ“œ View History</button>
        </div>

        <!-- íƒ€ì´í•‘ ì†ë„ ì„¤ì • -->
        <div class="typing-speed-control" role="group" aria-label="íƒ€ì´í•‘ ì†ë„ ì„¤ì •">
            <label for="typingSpeed">âš¡ Typing Speed (chars/sec):</label>
            <select id="typingSpeed" onchange="updateTypingSpeed()" aria-label="íƒ€ì´í•‘ ì†ë„ ì„ íƒ">
                <option value="13">13 (Slow)</option>
                <option value="15" selected>15 (Normal)</option>
                <option value="18">18 (Fast)</option>
                <option value="20">20 (Very Fast)</option>
                <option value="25">25 (Ultra Fast)</option>
                <option value="30">30 (Max Speed)</option>
            </select>
        </div>

        <div class="message-area">
            <textarea id="messageInput" placeholder="í•œê¸€/ì˜ë¬¸ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." onclick="openMessageModal()" aria-label="ë©”ì‹œì§€ ì…ë ¥" rows="1" style="resize: vertical; min-height: 48px; max-height: 120px; overflow-y: auto;"></textarea>
            <button class="send-btn" id="sendBtn" onclick="startCountdown()" disabled aria-label="ë©”ì‹œì§€ ì „ì†¡">ğŸ“¤ ì „ì†¡</button>
        </div>

        <!-- ë³€í™˜ ë¯¸ë¦¬ë³´ê¸° -->
        <div class="conversion-preview" id="conversionPreview" role="region" aria-label="í…ìŠ¤íŠ¸ ë³€í™˜ ë¯¸ë¦¬ë³´ê¸°" aria-live="polite">
            <strong>ğŸ”„ ë³€í™˜ ë¯¸ë¦¬ë³´ê¸°:</strong><br>
            <span id="previewText">ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ë©´ ë³€í™˜ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</span>
            <div class="protocol-info" id="protocolInfo"></div>
        </div>


        <!-- ì¹´ìš´íŠ¸ë‹¤ìš´ ëª¨ë‹¬ -->
        <div id="countdownModal" class="countdown-modal" style="display: none;">
            <div class="countdown-content">
                <h3>âŒ¨ï¸ í‚¤ë³´ë“œ ì…ë ¥ ì¤€ë¹„</h3>
                <div class="countdown-number" id="countdownNumber">5</div>
                <div class="countdown-message" id="countdownMessage">ë©”ëª¨ì¥ì— ì»¤ì„œë¥¼ ë†“ê³  ê¸°ë‹¤ë¦¬ì„¸ìš”...</div>
                <div class="countdown-instruction">
                    <p>ğŸ“ <strong>ì¤‘ìš”:</strong> ì…ë ¥ì„ ë°›ì„ í™”ë©´(ë©”ëª¨ì¥, í…ìŠ¤íŠ¸ ì—ë””í„° ë“±)ì— ì»¤ì„œë¥¼ í´ë¦­í•´ ë‘ì„¸ìš”!</p>
                    <p>â° ê³§ ìë™ íƒ€ì´í•‘ì´ ì‹œì‘ë©ë‹ˆë‹¤.</p>
                </div>
                <button class="cancel-btn" onclick="cancelCountdown()">âŒ ì·¨ì†Œ</button>
            </div>
        </div>

        <!-- Log Modal -->
        <div id="logModal" class="log-modal" style="display: none;" role="dialog" aria-labelledby="logModalTitle" aria-describedby="logModalBody">
            <div class="log-modal-content">
                <div class="log-modal-header">
                    <h3 class="log-modal-title" id="logModalTitle">ğŸ“‹ Connection Logs</h3>
                    <button class="log-modal-close" onclick="toggleLogModal()" aria-label="ë¡œê·¸ ëª¨ë‹¬ ë‹«ê¸°">Ã—</button>
                </div>
                <div class="log-modal-body" id="logModalBody" role="log" aria-live="polite">
                    <div class="log-entry log-info">ğŸŒ Web Bluetooth ì¤€ë¹„ë¨ (í•œê¸€ ìëª¨ ë³€í™˜ ì§€ì›)</div>
                </div>
            </div>
        </div>

        <!-- Message Input Modal -->
        <div id="messageModal" class="message-modal" style="display: none;" role="dialog" aria-labelledby="messageModalTitle">
            <div class="message-modal-content">
                <div class="message-modal-header">
                    <h3 class="message-modal-title" id="messageModalTitle">âœï¸ Message Editor</h3>
                </div>
                <textarea 
                    id="messageModalTextarea" 
                    class="message-modal-textarea" 
                    placeholder="í•œê¸€/ì˜ë¬¸ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                    aria-label="í™•ì¥ëœ ë©”ì‹œì§€ ì…ë ¥ ì˜ì—­"
                ></textarea>
                <div class="message-modal-preview" id="messageModalPreview">
                    <strong>ğŸ”„ ë³€í™˜ ë¯¸ë¦¬ë³´ê¸°:</strong><br>
                    <span id="modalPreviewText">ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ë©´ ë³€í™˜ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</span>
                    <div class="protocol-info" id="modalProtocolInfo"></div>
                </div>
                <div class="message-modal-footer">
                    <button class="cancel-btn" onclick="closeMessageModal()" aria-label="ì·¨ì†Œ">âŒ Cancel</button>
                    <button class="done-btn" onclick="applyMessageModal()" aria-label="ì ìš©">âœ“ Done</button>
                </div>
            </div>
        </div>

        <!-- History Modal -->
        <div id="historyModal" class="history-modal" style="display: none;" role="dialog" aria-labelledby="historyModalTitle">
            <div class="history-modal-content">
                <div class="history-modal-header">
                    <h3 class="history-modal-title" id="historyModalTitle">ğŸ“œ Message History</h3>
                    <button class="history-modal-close" onclick="closeHistoryModal()" aria-label="íˆìŠ¤í† ë¦¬ ëª¨ë‹¬ ë‹«ê¸°">Ã—</button>
                </div>
                
                <input type="text" id="historySearch" class="history-search" placeholder="Search messages..." aria-label="ë©”ì‹œì§€ ê²€ìƒ‰">
                
                <div class="history-stats" id="historyStats">
                    <span>Total: 0</span>
                    <span>Today: 0</span>
                    <span>This Week: 0</span>
                </div>
                
                <div class="history-list" id="historyList">
                    <div class="history-empty">No messages found. Start typing to build your history!</div>
                </div>
                
                <div class="history-modal-footer">
                    <button class="history-clear-btn" onclick="clearHistory()" aria-label="íˆìŠ¤í† ë¦¬ ì‚­ì œ">ğŸ—‘ï¸ Clear All</button>
                    <button class="history-export-btn" onclick="exportHistory()" aria-label="íˆìŠ¤í† ë¦¬ ë‚´ë³´ë‚´ê¸°">ğŸ“ Export</button>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h4>ğŸ“‹ ì‚¬ìš© ë°©ë²•:</h4>
            <ul>
                <li><strong>Chrome/Edge ë¸Œë¼ìš°ì €</strong>ì—ì„œë§Œ ë™ì‘í•©ë‹ˆë‹¤</li>
                <li>ì—°ê²° ë²„íŠ¼ì„ ëˆ„ë¥´ê³  <strong>"GHOSTYPE-6FED"</strong> ì„ íƒ</li>
                <li><strong>í•œê¸€/ì˜ë¬¸/í˜¼í•© í…ìŠ¤íŠ¸</strong> ëª¨ë‘ ì§€ì›ë©ë‹ˆë‹¤</li>
                <li>í•œê¸€ì€ ìë™ìœ¼ë¡œ <strong>ìëª¨ í‚¤ ì¡°í•©</strong>ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤</li>
                <li>ì…ë ¥ ì „ <strong>5ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´</strong>ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì „ì†¡</li>
                <li>ë©”ëª¨ì¥ì„ ì—´ì–´ë‘ê³  í…ŒìŠ¤íŠ¸í•´ë³´ì„¸ìš”!</li>
            </ul>
        </div>

        <div class="footer">
            ğŸ’¡ í•œê¸€ ì§€ì›: ã„±-ã…, ã…-ã…£ ìëª¨ë¥¼ QWERTY í‚¤ë¡œ ìë™ ë³€í™˜
        </div>
    </div>

    <script>
        // BLE ì„œë¹„ìŠ¤ ë° íŠ¹ì„± UUID
        const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const RX_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
        const TX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

        let device = null;
        let server = null;
        let service = null;
        let rxCharacteristic = null;
        let txCharacteristic = null;
        let countdownTimer = null;
        let countdownPending = null;
        let currentTypingSpeed = 15; // Default typing speed in characters per second

        // ===== í•œê¸€ â†’ ìëª¨ í‚¤ ë³€í™˜ ë¡œì§ =====

        // ë‘ë²Œì‹ í‚¤ë³´ë“œ ë§¤í•‘ í…Œì´ë¸”
        const QWERTY_TO_JAMO = {
            // ììŒ (ì™¼ì†)
            'q': 'ã…‚', 'w': 'ã…ˆ', 'e': 'ã„·', 'r': 'ã„±', 't': 'ã……',
            'a': 'ã…', 's': 'ã„´', 'd': 'ã…‡', 'f': 'ã„¹', 'g': 'ã…',
            'z': 'ã…‹', 'x': 'ã…Œ', 'c': 'ã…Š', 'v': 'ã…',
            
            // ëª¨ìŒ (ì˜¤ë¥¸ì†)
            'y': 'ã…›', 'u': 'ã…•', 'i': 'ã…‘', 'o': 'ã…', 'p': 'ã…”',
            'h': 'ã…—', 'j': 'ã…“', 'k': 'ã…', 'l': 'ã…£',
            'b': 'ã… ', 'n': 'ã…œ', 'm': 'ã…¡',
            
            // Shift ì¡°í•©
            'Q': 'ã…ƒ', 'W': 'ã…‰', 'E': 'ã„¸', 'R': 'ã„²', 'T': 'ã…†',
            'O': 'ã…’', 'P': 'ã…–'
        };

        // ì—­ë°©í–¥ ë§¤í•‘ (ìëª¨ â†’ QWERTY)
        const JAMO_TO_QWERTY = {};
        Object.keys(QWERTY_TO_JAMO).forEach(key => {
            JAMO_TO_QWERTY[QWERTY_TO_JAMO[key]] = key;
        });

        // ë³µí•© ëª¨ìŒ ë¶„í•´ ë§¤í•‘
        const COMPOUND_VOWELS = {
            'ã…˜': ['ã…—', 'ã…'],  // o + a
            'ã…™': ['ã…—', 'ã…'],  // o + ae
            'ã…š': ['ã…—', 'ã…£'],  // o + i
            'ã…': ['ã…œ', 'ã…“'],  // u + eo
            'ã…': ['ã…œ', 'ã…”'],  // u + e
            'ã…Ÿ': ['ã…œ', 'ã…£'],  // u + i
            'ã…¢': ['ã…¡', 'ã…£']   // eu + i
        };

        // í•œê¸€ ìœ ë‹ˆì½”ë“œ ë¶„í•´ í•¨ìˆ˜
        function decomposeHangul(char) {
            const code = char.charCodeAt(0);
            
            // í•œê¸€ ì™„ì„±í˜• ë²”ìœ„ ì²´í¬ (ê°€-í£)
            if (code < 0xAC00 || code > 0xD7A3) {
                return null;
            }
            
            const base = code - 0xAC00;
            const cho = Math.floor(base / 588);           // ì´ˆì„±
            const jung = Math.floor((base % 588) / 28);   // ì¤‘ì„±
            const jong = base % 28;                       // ì¢…ì„±
            
            // ìëª¨ ë°°ì—´
            const chosung = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
            const jungsung = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£'];
            const jongsung = ['','ã„±','ã„²','ã„±ã……','ã„´','ã„´ã…ˆ','ã„´ã…','ã„·','ã„¹','ã„¹ã„±','ã„¹ã…','ã„¹ã…‚','ã„¹ã……','ã„¹ã…Œ','ã„¹ã…','ã„¹ã…','ã…','ã…‚','ã…‚ã……','ã……','ã…†','ã…‡','ã…ˆ','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
            
            const result = [];
            
            // ì´ˆì„± ì¶”ê°€
            result.push(chosung[cho]);
            
            // ì¤‘ì„± ì¶”ê°€ (ë³µí•©ëª¨ìŒ ì²˜ë¦¬)
            const jungsungChar = jungsung[jung];
            if (COMPOUND_VOWELS[jungsungChar]) {
                // ë³µí•©ëª¨ìŒì¸ ê²½ìš° ë¶„í•´í•´ì„œ ì¶”ê°€
                result.push(...COMPOUND_VOWELS[jungsungChar]);
            } else {
                // ë‹¨ìˆœëª¨ìŒì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì¶”ê°€
                result.push(jungsungChar);
            }
            
            // ì¢…ì„± ì¶”ê°€ (ë³µí•©ììŒ ì²˜ë¦¬)
            if (jong > 0) {
                const jongChar = jongsung[jong];
                if (jongChar.length === 2) {
                    // ë³µí•© ì¢…ì„± (ì˜ˆ: ã„±ã……)
                    result.push(jongChar[0]);
                    result.push(jongChar[1]);
                } else {
                    result.push(jongChar);
                }
            }
            
            return result;
        }

        // ìëª¨ë¥¼ QWERTY í‚¤ë¡œ ë³€í™˜
        function jamoToQwerty(jamo) {
            // Check if the character exists in the mapping
            if (JAMO_TO_QWERTY.hasOwnProperty(jamo)) {
                return JAMO_TO_QWERTY[jamo];
            }
            
            // For unmapped characters, only return if it's a safe printable character
            const code = jamo.charCodeAt(0);
            if ((code >= 32 && code <= 126) || (code >= 0xAC00 && code <= 0xD7A3)) {
                return jamo;
            }
            
            // Filter out problematic characters that might cause issues
            return '';
        }

        // í•œê¸€ í…ìŠ¤íŠ¸ë¥¼ ìëª¨ í‚¤ ì¡°í•©ìœ¼ë¡œ ë³€í™˜
        function convertHangulToJamoKeys(text) {
            let result = '';
            
            for (let char of text) {
                const jamos = decomposeHangul(char);
                if (jamos) {
                    // í•œê¸€ì¸ ê²½ìš° ìëª¨ë¡œ ë¶„í•´ í›„ QWERTY í‚¤ë¡œ ë³€í™˜
                    for (let jamo of jamos) {
                        const qwertyKey = jamoToQwerty(jamo);
                        if (qwertyKey) {
                            result += qwertyKey;
                        } else {
                            console.warn('ë§¤í•‘ë˜ì§€ ì•Šì€ ìëª¨:', jamo, '(U+' + jamo.charCodeAt(0).toString(16).toUpperCase() + ')');
                        }
                    }
                } else {
                    // Check if it's a single jamo character (ã…‚ã…ˆã„·ã„± ë“±)
                    const qwertyKey = jamoToQwerty(char);
                    if (qwertyKey) {
                        result += qwertyKey;
                    } else {
                        // í•œê¸€ì´ ì•„ë‹Œ ê²½ìš° ê·¸ëŒ€ë¡œ
                        result += char;
                    }
                }
            }
            
            return result;
        }

        // í…ìŠ¤íŠ¸ íƒ€ì… ë¶„ì„
        function analyzeText(text) {
            let hasKorean = false;
            let hasEnglish = false;
            let hasSpecial = false;
            
            for (let char of text) {
                const code = char.charCodeAt(0);
                if (code >= 0xAC00 && code <= 0xD7A3) {
                    hasKorean = true;
                } else if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) {
                    hasEnglish = true;
                } else if (code >= 32 && code <= 126) {
                    hasSpecial = true;
                }
            }
            
            if (hasKorean && hasEnglish) return 'mixed';
            if (hasKorean) return 'korean';
            if (hasEnglish || hasSpecial) return 'english';
            return 'unknown';
        }

        // ìŠ¤ë§ˆíŠ¸ í…ìŠ¤íŠ¸ ë³€í™˜ (í”„ë¡œí† ì½œ í¬í•¨)
        function convertTextWithProtocol(text) {
            console.log('convertTextWithProtocol ì‹œì‘, ì…ë ¥:', JSON.stringify(text));
            console.log('ì…ë ¥ì— ì—”í„°í‚¤ ìˆë‚˜?', text.includes('\n'));
            
            const type = analyzeText(text);
            console.log('analyzeText ê²°ê³¼:', type);
            
            if (type === 'korean' || type === 'mixed') {
                // í•œê¸€ì´ í¬í•¨ëœ ê²½ìš°: ìëª¨ í‚¤ë¡œ ë³€í™˜ í›„ JSON í˜•íƒœë¡œ ì „ì†¡
                const jamoKeys = convertHangulToJamoKeys(text);
                console.log('jamoKeys ë³€í™˜ ê²°ê³¼:', JSON.stringify(jamoKeys));
                console.log('ë³€í™˜ í›„ ì—”í„°í‚¤ ìˆë‚˜?', jamoKeys.includes('\n'));
                
                const jsonData = {
                    text: jamoKeys,
                    speed_cps: currentTypingSpeed,
                    type: 'korean'
                };
                console.log('í•œê¸€ JSON ìƒì„±:', jsonData);
                console.log('í˜„ì¬ íƒ€ì´í•‘ ì†ë„:', currentTypingSpeed);
                
                const result = {
                    original: text,
                    converted: jamoKeys,
                    protocol: JSON.stringify(jsonData),
                    type: type,
                    description: 'í•œê¸€ ìëª¨ í‚¤ ë³€í™˜'
                };
                console.log('ìµœì¢… í”„ë¡œí† ì½œ:', JSON.stringify(result.protocol));
                console.log('í¬í•¨ëœ íƒ€ì´í•‘ ì†ë„:', currentTypingSpeed);
                return result;
            } else {
                // ìˆœìˆ˜ ì˜ë¬¸ì¸ ê²½ìš°: JSON í˜•íƒœë¡œ ì „ì†¡
                console.log('ì˜ë¬¸ ì²˜ë¦¬ - ì›ë³¸ ê·¸ëŒ€ë¡œ');
                
                const jsonData = {
                    text: text,
                    speed_cps: currentTypingSpeed,
                    type: 'english'
                };
                console.log('ì˜ë¬¸ JSON ìƒì„±:', jsonData);
                console.log('í˜„ì¬ íƒ€ì´í•‘ ì†ë„:', currentTypingSpeed);
                
                const result = {
                    original: text,
                    converted: text,
                    protocol: JSON.stringify(jsonData),
                    type: 'english',
                    description: 'ì˜ë¬¸ ì§ì ‘ ì…ë ¥'
                };
                console.log('ìµœì¢… í”„ë¡œí† ì½œ:', JSON.stringify(result.protocol));
                console.log('í¬í•¨ëœ íƒ€ì´í•‘ ì†ë„:', currentTypingSpeed);
                return result;
            }
        }

        // ì‹¤ì‹œê°„ ë³€í™˜ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        // ê¸´ í…ìŠ¤íŠ¸ ì¶•ì•½ í•¨ìˆ˜
        function truncateText(text, maxLength = 100) {
            if (!text || text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + '...';
        }

        function updateConversionPreview() {
            const input = document.getElementById('messageInput');
            const preview = document.getElementById('conversionPreview');
            const previewText = document.getElementById('previewText');
            const protocolInfo = document.getElementById('protocolInfo');
            const text = input.value;
            
            // ë””ë²„ê¹…: ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸ ì‹œ í…ìŠ¤íŠ¸ í™•ì¸
            console.log('updateConversionPreview í˜¸ì¶œ, í…ìŠ¤íŠ¸:', JSON.stringify(text));
            console.log('ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ì— ì—”í„°í‚¤ ìˆë‚˜?', text.includes('\n'));
            
            if (!text) {
                preview.className = 'conversion-preview';
                previewText.textContent = 'ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ë©´ ë³€í™˜ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤';
                protocolInfo.textContent = '';
                return;
            }
            
            const result = convertTextWithProtocol(text);
            
            // ë¯¸ë¦¬ë³´ê¸° ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            preview.className = `conversion-preview ${result.type}`;
            
            // ê¸´ í…ìŠ¤íŠ¸ ì¶•ì•½
            const truncatedOriginal = truncateText(result.original, 50);
            const truncatedConverted = truncateText(result.converted, 50);
            
            // ì—”í„°í‚¤ ë“± íŠ¹ìˆ˜ ë¬¸ì í‘œì‹œ
            const displayOriginal = truncatedOriginal
                .replace(/\n/g, 'â†µ<br>')
                .replace(/\t/g, 'â†’')
                .replace(/\r/g, 'â†“');
            
            const displayConverted = truncatedConverted
                .replace(/\n/g, 'â†µ<br>')
                .replace(/\t/g, 'â†’')
                .replace(/\r/g, 'â†“');
            
            // ë³€í™˜ ê²°ê³¼ í‘œì‹œ
            if (result.type === 'korean' || result.type === 'mixed') {
                previewText.innerHTML = `
                    <strong>ì›ë³¸:</strong> ${displayOriginal}<br>
                    <strong>ìëª¨:</strong> ${displayConverted}<br>
                    <strong>ì„¤ëª…:</strong> ${result.description}
                `;
            } else {
                previewText.innerHTML = `
                    <strong>í…ìŠ¤íŠ¸:</strong> ${displayOriginal}<br>
                    <strong>ì„¤ëª…:</strong> ${result.description}
                `;
            }
            
            // í”„ë¡œí† ì½œ ì •ë³´ë„ ì¶•ì•½
            const truncatedProtocol = truncateText(result.protocol, 80);
            protocolInfo.textContent = `ì „ì†¡ í”„ë¡œí† ì½œ: ${truncatedProtocol}`;
        }

        // ===== BLE í†µì‹  í•¨ìˆ˜ë“¤ =====

        function addLog(message, type = 'info') {
            const log = document.getElementById('logModalBody');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function toggleLogModal() {
            const modal = document.getElementById('logModal');
            modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
        }

        // Close modals when clicking outside
        document.getElementById('logModal').addEventListener('click', function(event) {
            if (event.target === this) {
                toggleLogModal();
            }
        });

        document.getElementById('messageModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeMessageModal();
            }
        });

        document.getElementById('countdownModal').addEventListener('click', function(event) {
            if (event.target === this) {
                cancelCountdown();
            }
        });

        // Typing Speed Control
        function updateTypingSpeed() {
            const speedSelect = document.getElementById('typingSpeed');
            const newSpeed = parseInt(speedSelect.value);
            
            console.log('íƒ€ì´í•‘ ì†ë„ ë³€ê²½:', currentTypingSpeed, 'â†’', newSpeed);
            currentTypingSpeed = newSpeed;
            
            // Save to localStorage
            localStorage.setItem('ghostype_typing_speed', currentTypingSpeed);
            
            // Send configuration to ESP32 if connected
            if (rxCharacteristic) {
                const configData = {
                    mode: "typing",
                    speed_cps: currentTypingSpeed
                };
                const configProtocol = `GHTYPE_CFG:${JSON.stringify(configData)}`;
                
                console.log('ì†ë„ ì„¤ì • ì „ì†¡:', configProtocol);
                
                sendData(configProtocol).then(success => {
                    if (success) {
                        addLog(`âš¡ íƒ€ì´í•‘ ì†ë„ ë³€ê²½: ${currentTypingSpeed} chars/sec`, 'success');
                    }
                });
            } else {
                addLog(`âš¡ íƒ€ì´í•‘ ì†ë„ ì„¤ì •: ${currentTypingSpeed} chars/sec (ì—°ê²° í›„ ì ìš©)`, 'info');
            }
        }

        // Load saved typing speed
        function loadTypingSpeed() {
            const savedSpeed = localStorage.getItem('ghostype_typing_speed');
            if (savedSpeed) {
                currentTypingSpeed = parseInt(savedSpeed);
                document.getElementById('typingSpeed').value = savedSpeed;
            }
        }

        // Message Modal Functions
        function openMessageModal() {
            const modal = document.getElementById('messageModal');
            const textarea = document.getElementById('messageModalTextarea');
            const input = document.getElementById('messageInput');
            
            // Copy current value to modal
            textarea.value = input.value;
            modal.style.display = 'flex';
            
            // Focus textarea and update preview
            textarea.focus();
            updateModalPreview();
        }

        function closeMessageModal() {
            const modal = document.getElementById('messageModal');
            modal.style.display = 'none';
        }

        function applyMessageModal() {
            const textarea = document.getElementById('messageModalTextarea');
            const input = document.getElementById('messageInput');
            
            // ë””ë²„ê¹…: í…ìŠ¤íŠ¸ê°€ ì œëŒ€ë¡œ ë³µì‚¬ë˜ëŠ”ì§€ í™•ì¸
            console.log('íŒì—… í…ìŠ¤íŠ¸:', JSON.stringify(textarea.value));
            console.log('íŒì—… í…ìŠ¤íŠ¸ì— ì—”í„°í‚¤ ìˆë‚˜?', textarea.value.includes('\n'));
            
            // Copy value back to input
            input.value = textarea.value;
            
            console.log('ë©”ì¸ ì…ë ¥ì°½ í…ìŠ¤íŠ¸:', JSON.stringify(input.value));
            console.log('ë©”ì¸ ì…ë ¥ì°½ì— ì—”í„°í‚¤ ìˆë‚˜?', input.value.includes('\n'));
            
            updateConversionPreview();
            closeMessageModal();
        }

        function updateModalPreview() {
            const textarea = document.getElementById('messageModalTextarea');
            const previewText = document.getElementById('modalPreviewText');
            const protocolInfo = document.getElementById('modalProtocolInfo');
            const text = textarea.value;
            
            if (!text) {
                previewText.textContent = 'ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ë©´ ë³€í™˜ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤';
                protocolInfo.textContent = '';
                return;
            }
            
            const result = convertTextWithProtocol(text);
            
            // ê¸´ í…ìŠ¤íŠ¸ ì¶•ì•½ (ëª¨ë‹¬ì—ì„œëŠ” ì¡°ê¸ˆ ë” ê¸¸ê²Œ)
            const truncatedOriginal = truncateText(result.original, 80);
            const truncatedConverted = truncateText(result.converted, 80);
            
            // ì—”í„°í‚¤ ë“± íŠ¹ìˆ˜ ë¬¸ì í‘œì‹œ
            const displayOriginal = truncatedOriginal
                .replace(/\n/g, 'â†µ<br>')
                .replace(/\t/g, 'â†’')
                .replace(/\r/g, 'â†“');
            
            const displayConverted = truncatedConverted
                .replace(/\n/g, 'â†µ<br>')
                .replace(/\t/g, 'â†’')
                .replace(/\r/g, 'â†“');
            
            if (result.type === 'korean' || result.type === 'mixed') {
                previewText.innerHTML = `
                    <strong>ì›ë³¸:</strong> ${displayOriginal}<br>
                    <strong>ìëª¨:</strong> ${displayConverted}<br>
                    <strong>ì„¤ëª…:</strong> ${result.description}
                `;
            } else {
                previewText.innerHTML = `
                    <strong>í…ìŠ¤íŠ¸:</strong> ${displayOriginal}<br>
                    <strong>ì„¤ëª…:</strong> ${result.description}
                `;
            }
            
            // í”„ë¡œí† ì½œ ì •ë³´ë„ ì¶•ì•½
            const truncatedProtocol = truncateText(result.protocol, 100);
            protocolInfo.textContent = `ì „ì†¡ í”„ë¡œí† ì½œ: ${truncatedProtocol}`;
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function updateUI(connected) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            // ì…ë ¥ì°½ì€ í•­ìƒ í™œì„±í™” (ë¯¸ë¦¬ë³´ê¸°ë¥¼ ìœ„í•´)
            // document.getElementById('messageInput').disabled = !connected;
            document.getElementById('sendBtn').disabled = !connected;
            
            if (connected) {
                addLog('ğŸ‡°ğŸ‡· í•œê¸€ ìëª¨ ë³€í™˜ ê¸°ëŠ¥ í™œì„±í™”', 'info');
                addLog('âŒ¨ï¸ ëª¨ë“  í•œê¸€ì´ ìë™ìœ¼ë¡œ ìëª¨ í‚¤ë¡œ ë³€í™˜ë©ë‹ˆë‹¤', 'info');
            }
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
        function startCountdown() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) {
                addLog('âš ï¸ ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”', 'error');
                return;
            }

            if (!rxCharacteristic) {
                addLog('âŒ ë¨¼ì € GHOSTYPE ë””ë°”ì´ìŠ¤ì— ì—°ê²°í•˜ì„¸ìš”', 'error');
                return;
            }

            const result = convertTextWithProtocol(message);
            startCountdownWithResult(result, () => {
                sendData(result.protocol);
                input.value = '';
                updateConversionPreview();
            });
        }

        // í…ŒìŠ¤íŠ¸ í…ìŠ¤íŠ¸ ì „ì†¡
        function testText(text) {
            const result = convertTextWithProtocol(text);
            startCountdownWithResult(result, () => {
                sendData(result.protocol);
            });
        }

        // íŠ¹ìˆ˜ í‚¤ ì „ì†¡
        function testSpecial(command) {
            const protocol = `GHTYPE_SPE:${command}`;
            const result = {
                original: command,
                converted: command,
                protocol: protocol,
                type: 'special',
                description: 'íŠ¹ìˆ˜ í‚¤ ëª…ë ¹'
            };
            
            startCountdownWithResult(result, () => {
                sendData(protocol);
            });
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ (ë³€í™˜ ê²°ê³¼ í¬í•¨)
        function startCountdownWithResult(result, callback) {
            if (!rxCharacteristic) {
                addLog('âŒ ì—°ê²°ë˜ì§€ ì•ŠìŒ', 'error');
                return;
            }

            const modal = document.getElementById('countdownModal');
            const numberEl = document.getElementById('countdownNumber');
            const messageEl = document.getElementById('countdownMessage');
            
            modal.style.display = 'flex';
            
            let count = 5;
            countdownPending = callback;
            
            function updateCountdown() {
                numberEl.textContent = count;
                
                if (count > 0) {
                    messageEl.textContent = `${count}ì´ˆ í›„ ì…ë ¥ì´ ì‹œì‘ë©ë‹ˆë‹¤...`;
                    count--;
                    countdownTimer = setTimeout(updateCountdown, 1000);
                } else {
                    messageEl.textContent = 'ì…ë ¥ ì¤‘... âŒ¨ï¸';
                    numberEl.textContent = 'âŒ¨ï¸';
                    numberEl.style.animation = 'none';
                    
                    setTimeout(() => {
                        modal.style.display = 'none';
                        if (countdownPending) {
                            countdownPending();
                            countdownPending = null;
                            addLog(`âŒ¨ï¸ ì „ì†¡: ${result.description} - "${result.original}"`, 'success');
                        }
                        numberEl.style.animation = 'pulse 1s ease-in-out infinite';
                    }, 1000);
                }
            }
            
            updateCountdown();
            addLog(`â° 5ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´: ${result.description}`, 'info');
        }

        function cancelCountdown() {
            if (countdownTimer) {
                clearTimeout(countdownTimer);
                countdownTimer = null;
            }
            countdownPending = null;
            
            const modal = document.getElementById('countdownModal');
            modal.style.display = 'none';
            
            addLog('âŒ ì…ë ¥ ì·¨ì†Œë¨', 'info');
        }

        // BLE ì—°ê²°
        async function connectDevice() {
            try {
                addLog('ğŸ” GHOSTYPE ë””ë°”ì´ìŠ¤ ê²€ìƒ‰ ì¤‘...', 'info');
                updateStatus('ğŸ” ë””ë°”ì´ìŠ¤ ê²€ìƒ‰ ì¤‘...', 'connecting');

                device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'GHOSTYPE' },
                        { services: [SERVICE_UUID] }
                    ],
                    optionalServices: [SERVICE_UUID]
                });

                addLog(`ğŸ“± ë””ë°”ì´ìŠ¤ ë°œê²¬: ${device.name}`, 'success');
                device.addEventListener('gattserverdisconnected', onDisconnected);

                addLog('ğŸ”— GATT ì„œë²„ ì—°ê²° ì¤‘...', 'info');
                server = await device.gatt.connect();

                addLog('ğŸ“¡ Nordic UART ì„œë¹„ìŠ¤ ê²€ìƒ‰ ì¤‘...', 'info');
                service = await server.getPrimaryService(SERVICE_UUID);

                addLog('ğŸ”§ íŠ¹ì„± ì„¤ì • ì¤‘...', 'info');
                rxCharacteristic = await service.getCharacteristic(RX_CHAR_UUID);
                txCharacteristic = await service.getCharacteristic(TX_CHAR_UUID);

                await txCharacteristic.startNotifications();
                txCharacteristic.addEventListener('characteristicvaluechanged', onDataReceived);

                addLog('ğŸ‰ ì—°ê²° ì™„ë£Œ! í•œê¸€/ì˜ë¬¸ ëª¨ë‘ ì§€ì›ë©ë‹ˆë‹¤', 'success');
                updateStatus('ğŸŸ¢ ì—°ê²°ë¨ - í•œê¸€/ì˜ë¬¸ ì…ë ¥ ê°€ëŠ¥', 'connected');
                updateUI(true);

                // ìë™ ì „ì†¡ ì œê±°ë¨ - ì‚¬ìš©ìê°€ í•„ìš”í•  ë•Œë§Œ ìˆ˜ë™ìœ¼ë¡œ ì „ì†¡

            } catch (error) {
                addLog(`âŒ ì—°ê²° ì‹¤íŒ¨: ${error.message}`, 'error');
                updateStatus('ğŸ”´ ì—°ê²° ì‹¤íŒ¨', 'disconnected');
                console.error('Connection failed:', error);
            }
        }

        function onDataReceived(event) {
            const value = new TextDecoder().decode(event.target.value);
            addLog(`ğŸ“¨ ESP32 ì‘ë‹µ: "${value}"`, 'data');
        }

        function onDisconnected() {
            addLog('ğŸ‘‹ ë””ë°”ì´ìŠ¤ ì—°ê²° í•´ì œë¨', 'info');
            updateStatus('ğŸ”´ ì—°ê²° í•´ì œë¨', 'disconnected');
            updateUI(false);
            
            device = null;
            server = null;
            service = null;
            rxCharacteristic = null;
            txCharacteristic = null;
        }

        async function disconnectDevice() {
            if (device && device.gatt.connected) {
                await device.gatt.disconnect();
            }
        }

        // BLE ì—°ê²° ìƒíƒœ ì§„ë‹¨ í•¨ìˆ˜
        function diagnoseBLEConnection() {
            console.log('=== BLE ì—°ê²° ì§„ë‹¨ ===');
            console.log('device:', device);
            console.log('device.gatt:', device ? device.gatt : 'device is null');
            console.log('device.gatt.connected:', device && device.gatt ? device.gatt.connected : 'gatt is null');
            console.log('server:', server);
            console.log('service:', service);
            console.log('rxCharacteristic:', rxCharacteristic);
            console.log('txCharacteristic:', txCharacteristic);
            
            if (device && device.gatt) {
                addLog(`ğŸ” BLE ì—°ê²° ìƒíƒœ: ${device.gatt.connected ? 'ì—°ê²°ë¨' : 'ì—°ê²° ëŠê¹€'}`, 'info');
            } else {
                addLog('ğŸ” BLE ë””ë°”ì´ìŠ¤ ê°ì²´ê°€ ì—†ìŒ', 'error');
            }
        }

        async function sendData(message) {
            if (!rxCharacteristic) {
                addLog('âŒ ì—°ê²°ë˜ì§€ ì•ŠìŒ', 'error');
                diagnoseBLEConnection();
                return false;
            }

            // BLE ì—°ê²° ìƒíƒœ í™•ì¸
            if (!device || !device.gatt.connected) {
                addLog('âŒ BLE ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤', 'error');
                diagnoseBLEConnection();
                return false;
            }

            console.log('sendData í˜¸ì¶œ, ë©”ì‹œì§€:', JSON.stringify(message));
            console.log('ì „ì†¡í•  ë©”ì‹œì§€ì— ì—”í„°í‚¤ ìˆë‚˜?', message.includes('\n'));

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                
                console.log('ì¸ì½”ë”©ëœ ë°ì´í„° ê¸¸ì´:', data.length);
                
                // BLE writeValueëŠ” 512ë°”ì´íŠ¸ë¡œ ì œí•œë¨ - ì²­í¬ë¡œ ë¶„í•  ì „ì†¡
                const MAX_CHUNK_SIZE = 500; // ì•ˆì „ë§ˆì§„ì„ ìœ„í•´ 500ë°”ì´íŠ¸ë¡œ ì œí•œ
                
                if (data.length > 10000) {
                    addLog(`âš ï¸ í…ìŠ¤íŠ¸ê°€ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (${data.length}ë°”ì´íŠ¸). 10KB ì´í•˜ë¡œ ì¤„ì—¬ì£¼ì„¸ìš”.`, 'error');
                    return false;
                }
                
                if (data.length <= MAX_CHUNK_SIZE) {
                    // ì‘ì€ ë°ì´í„°ëŠ” í•œ ë²ˆì— ì „ì†¡ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
                    let retryCount = 0;
                    const maxRetries = 3;
                    
                    while (retryCount < maxRetries) {
                        try {
                            // ì—°ê²° ìƒíƒœ ë° íŠ¹ì„± ìœ íš¨ì„± ì²´í¬
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤');
                            }
                            
                            await rxCharacteristic.writeValue(data);
                            addLog(`ğŸ“¤ í”„ë¡œí† ì½œ ì „ì†¡ (${data.length}ë°”ì´íŠ¸): "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`, 'success');
                            break; // ì„±ê³µì‹œ ë£¨í”„ ì¢…ë£Œ
                        } catch (simpleError) {
                            retryCount++;
                            console.warn(`ë‹¨ìˆœ ì „ì†¡ ì‹¤íŒ¨ (${retryCount}/${maxRetries}):`, simpleError.message);
                            
                            // íŠ¹ì • ì—ëŸ¬ íƒ€ì… ì²´í¬
                            if (simpleError.message.includes('GATT operation failed') || 
                                simpleError.message.includes('Cannot read properties of null')) {
                                addLog(`âš ï¸ BLE ì—°ê²° ë¶ˆì•ˆì • ê°ì§€ (ë‹¨ìˆœ ì „ì†¡): ${simpleError.message}`, 'warning');
                                
                                // ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ ì „ì†¡ ì¤‘ë‹¨ë¨');
                                }
                            }
                            
                            if (retryCount >= maxRetries) {
                                throw new Error(`ë‹¨ìˆœ ì „ì†¡ ì‹¤íŒ¨: ${simpleError.message}`);
                            }
                            
                            // ì¬ì‹œë„ ì „ ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ ì¬ì‹œë„ ë¶ˆê°€ëŠ¥');
                            }
                            
                            // ì¬ì‹œë„ ì „ ë”œë ˆì´ (ì—ëŸ¬ íƒ€ì…ì— ë”°ë¼ ì¡°ì •)
                            const delayMs = simpleError.message.includes('GATT operation failed') ? 1000 : 500;
                            await new Promise(resolve => setTimeout(resolve, delayMs));
                        }
                    }
                } else {
                    // í° ë°ì´í„°ëŠ” ì²­í¬ë¡œ ë¶„í•  ì „ì†¡
                    const totalChunks = Math.ceil(data.length / MAX_CHUNK_SIZE);
                    addLog(`ğŸ“¤ í° ë°ì´í„°ë¥¼ ì²­í¬ë¡œ ë¶„í•  ì „ì†¡ (ì´ ${data.length}ë°”ì´íŠ¸, ${totalChunks}ê°œ ì²­í¬)`, 'info');
                    
                    // ì²« ë²ˆì§¸ ì²­í¬ì— íŠ¹ë³„í•œ í—¤ë” ì¶”ê°€ë¡œ ESP32ì—ê²Œ ë¶„í•  ì „ì†¡ì„ì„ ì•Œë¦¼
                    const firstChunkHeader = "CHUNK_START:";
                    const headerBytes = encoder.encode(firstChunkHeader);
                    
                    let chunkIndex = 0;
                    let dataOffset = 0;
                    
                    while (dataOffset < data.length) {
                        let chunk;
                        
                        if (chunkIndex === 0) {
                            // ì²« ë²ˆì§¸ ì²­í¬: í—¤ë” + ë°ì´í„°
                            const availableSpace = MAX_CHUNK_SIZE - headerBytes.length;
                            const dataChunk = data.slice(dataOffset, dataOffset + availableSpace);
                            chunk = new Uint8Array(headerBytes.length + dataChunk.length);
                            chunk.set(headerBytes, 0);
                            chunk.set(dataChunk, headerBytes.length);
                            dataOffset += availableSpace;
                        } else {
                            // ì´í›„ ì²­í¬ë“¤: ë°ì´í„°ë§Œ
                            const dataChunk = data.slice(dataOffset, dataOffset + MAX_CHUNK_SIZE);
                            chunk = dataChunk;
                            dataOffset += MAX_CHUNK_SIZE;
                        }
                        
                        // ì²­í¬ ì „ì†¡ ì¬ì‹œë„ ë¡œì§
                        let retryCount = 0;
                        const maxRetries = 3;
                        
                        while (retryCount < maxRetries) {
                            try {
                                // ì—°ê²° ìƒíƒœ ë° íŠ¹ì„± ìœ íš¨ì„± ì²´í¬
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤');
                                }
                                
                                await rxCharacteristic.writeValue(chunk);
                                
                                // ì§„í–‰ ìƒí™© í‘œì‹œ
                                const progress = Math.round((chunkIndex + 1) / totalChunks * 100);
                                console.log(`ì²­í¬ ${chunkIndex + 1}/${totalChunks} ì „ì†¡ (${progress}%): ${chunk.length}ë°”ì´íŠ¸`);
                                addLog(`ğŸ“¤ ì²­í¬ ${chunkIndex + 1}/${totalChunks} ì „ì†¡ ì™„ë£Œ (${progress}%)`, 'info');
                                
                                break; // ì„±ê³µì‹œ ë£¨í”„ ì¢…ë£Œ
                            } catch (chunkError) {
                                retryCount++;
                                console.warn(`ì²­í¬ ${chunkIndex + 1} ì „ì†¡ ì‹¤íŒ¨ (${retryCount}/${maxRetries}):`, chunkError.message);
                                
                                // íŠ¹ì • ì—ëŸ¬ íƒ€ì… ì²´í¬
                                if (chunkError.message.includes('GATT operation failed') || 
                                    chunkError.message.includes('Cannot read properties of null')) {
                                    addLog(`âš ï¸ BLE ì—°ê²° ë¶ˆì•ˆì • ê°ì§€ (ì²­í¬ ${chunkIndex + 1}): ${chunkError.message}`, 'warning');
                                    
                                    // ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                                    if (!rxCharacteristic || !device || !device.gatt.connected) {
                                        throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ ì „ì†¡ ì¤‘ë‹¨ë¨');
                                    }
                                }
                                
                                if (retryCount >= maxRetries) {
                                    throw new Error(`ì²­í¬ ${chunkIndex + 1} ì „ì†¡ ì‹¤íŒ¨: ${chunkError.message}`);
                                }
                                
                                // ì¬ì‹œë„ ì „ ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ ì¬ì‹œë„ ë¶ˆê°€ëŠ¥');
                                }
                                
                                // ì¬ì‹œë„ ì „ ë” ê¸´ ë”œë ˆì´ (ì—ëŸ¬ íƒ€ì…ì— ë”°ë¼ ì¡°ì •)
                                const delayMs = chunkError.message.includes('GATT operation failed') ? 1000 : 500;
                                await new Promise(resolve => setTimeout(resolve, delayMs));
                            }
                        }
                        
                        chunkIndex++;
                        
                        // ì²­í¬ ê°„ ë”œë ˆì´ ì¦ê°€ (BLE ì•ˆì •ì„± í–¥ìƒ)
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                    
                    // ì „ì†¡ ì™„ë£Œ ë§ˆì»¤ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
                    const endMarker = encoder.encode("CHUNK_END");
                    let endMarkerRetryCount = 0;
                    const endMarkerMaxRetries = 3;
                    
                    while (endMarkerRetryCount < endMarkerMaxRetries) {
                        try {
                            // ì—°ê²° ìƒíƒœ ë° íŠ¹ì„± ìœ íš¨ì„± ì²´í¬
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤');
                            }
                            
                            await rxCharacteristic.writeValue(endMarker);
                            console.log('CHUNK_END ë§ˆì»¤ ì „ì†¡ ì„±ê³µ');
                            break;
                        } catch (endError) {
                            endMarkerRetryCount++;
                            console.warn(`CHUNK_END ë§ˆì»¤ ì „ì†¡ ì‹¤íŒ¨ (${endMarkerRetryCount}/${endMarkerMaxRetries}):`, endError.message);
                            
                            // íŠ¹ì • ì—ëŸ¬ íƒ€ì… ì²´í¬
                            if (endError.message.includes('GATT operation failed') || 
                                endError.message.includes('Cannot read properties of null')) {
                                addLog(`âš ï¸ BLE ì—°ê²° ë¶ˆì•ˆì • ê°ì§€ (CHUNK_END): ${endError.message}`, 'warning');
                                
                                // ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ CHUNK_END ì „ì†¡ ì¤‘ë‹¨ë¨');
                                }
                            }
                            
                            if (endMarkerRetryCount >= endMarkerMaxRetries) {
                                throw new Error(`CHUNK_END ë§ˆì»¤ ì „ì†¡ ì‹¤íŒ¨: ${endError.message}`);
                            }
                            
                            // ì¬ì‹œë„ ì „ ì—°ê²° ìƒíƒœ ì¬í™•ì¸
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE ì—°ê²°ì´ ëŠì–´ì ¸ì„œ ì¬ì‹œë„ ë¶ˆê°€ëŠ¥');
                            }
                            
                            // ì¬ì‹œë„ ì „ ë” ê¸´ ë”œë ˆì´ (ì—ëŸ¬ íƒ€ì…ì— ë”°ë¼ ì¡°ì •)
                            const delayMs = endError.message.includes('GATT operation failed') ? 1000 : 500;
                            await new Promise(resolve => setTimeout(resolve, delayMs));
                        }
                    }
                    
                    addLog(`ğŸ“¤ ë¶„í•  ì „ì†¡ ì™„ë£Œ: ${totalChunks}ê°œ ì²­í¬ (${data.length}ë°”ì´íŠ¸)`, 'success');
                }
                
                return true;
            } catch (error) {
                addLog(`âŒ ì „ì†¡ ì‹¤íŒ¨: ${error.message}`, 'error');
                console.error('ì „ì†¡ ì—ëŸ¬:', error);
                
                // ì „ì†¡ ì‹¤íŒ¨ ì‹œ ì—°ê²° ìƒíƒœ ì¬ì§„ë‹¨
                diagnoseBLEConnection();
                
                // ì—ëŸ¬ íƒ€ì…ë³„ ë¶„ì„
                if (error.message.includes('GATT operation failed')) {
                    addLog('ğŸ’¡ GATT ì‘ì—… ì‹¤íŒ¨ - ESP32 ì‘ë‹µ ì—†ìŒ ë˜ëŠ” ì—°ê²° ë¶ˆì•ˆì •', 'warning');
                } else if (error.message.includes('Cannot read properties of null')) {
                    addLog('ğŸ’¡ íŠ¹ì„± ê°ì²´ê°€ null - ì—°ê²°ì´ ì˜ˆìƒë³´ë‹¤ ë¹¨ë¦¬ ëŠì–´ì§', 'warning');
                } else if (error.message.includes('NetworkError')) {
                    addLog('ğŸ’¡ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ - ë¸”ë£¨íˆ¬ìŠ¤ í•˜ë“œì›¨ì–´ ë¬¸ì œ ê°€ëŠ¥ì„±', 'warning');
                }
                
                return false;
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('messageInput').addEventListener('input', function(event) {
            // í…ìŠ¤íŠ¸ì—ë¦¬ì–´ ìë™ í¬ê¸° ì¡°ì • (ìµœëŒ€ 120px)
            const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            
            updateConversionPreview();
        });
        
        document.getElementById('messageInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                startCountdown();
            }
            // Shift+EnterëŠ” ì¤„ë°”ê¿ˆ í—ˆìš©
        });
        
        // Add paste event listener for main input field
        document.getElementById('messageInput').addEventListener('paste', function(event) {
            event.preventDefault();
            
            // Get clipboard data
            const clipboardData = event.clipboardData || window.clipboardData;
            let pastedText = clipboardData.getData('text');
            
            // Clean the pasted text to remove any problematic characters
            pastedText = pastedText.replace(/[^\x00-\x7F\uAC00-\uD7A3\u3130-\u318F]/g, '');
            
            // Insert the cleaned text at cursor position
            const input = event.target;
            const startPos = input.selectionStart;
            const endPos = input.selectionEnd;
            const textBefore = input.value.substring(0, startPos);
            const textAfter = input.value.substring(endPos);
            
            input.value = textBefore + pastedText + textAfter;
            
            // Set cursor position after pasted text
            const newCursorPos = startPos + pastedText.length;
            input.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update the preview
            updateConversionPreview();
        });

        // Message modal textarea event listener
        document.getElementById('messageModalTextarea').addEventListener('input', updateModalPreview);
        
        // Add paste event listener for proper clipboard handling
        document.getElementById('messageModalTextarea').addEventListener('paste', function(event) {
            event.preventDefault();
            
            // Get clipboard data
            const clipboardData = event.clipboardData || window.clipboardData;
            let pastedText = clipboardData.getData('text');
            
            // Clean the pasted text to remove any problematic characters
            pastedText = pastedText.replace(/[^\x00-\x7F\uAC00-\uD7A3\u3130-\u318F]/g, '');
            
            // Insert the cleaned text at cursor position
            const textarea = event.target;
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const textBefore = textarea.value.substring(0, startPos);
            const textAfter = textarea.value.substring(endPos);
            
            textarea.value = textBefore + pastedText + textAfter;
            
            // Set cursor position after pasted text
            const newCursorPos = startPos + pastedText.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update the preview
            updateModalPreview();
        });
        
        // Close modals on Escape key and handle keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                if (document.getElementById('logModal').style.display === 'flex') {
                    toggleLogModal();
                }
                if (document.getElementById('messageModal').style.display === 'flex') {
                    closeMessageModal();
                }
            }
            
            // Handle Ctrl+V / Cmd+V for paste operations
            if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                // Let the paste event handlers handle this
                // Don't prevent default here to allow normal paste behavior
            }
        });

        // Web Bluetooth ì§€ì› í™•ì¸
        if (!navigator.bluetooth) {
            addLog('âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” Web Bluetoothë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤', 'error');
            updateStatus('ğŸš« Web Bluetooth ë¯¸ì§€ì›', 'disconnected');
        }

        // ì´ˆê¸° ìƒíƒœ
        updateUI(false);
        updateConversionPreview();
        loadTypingSpeed(); // Load saved typing speed
        addLog('ğŸ’¡ ì—°ê²° í›„ í•œê¸€/ì˜ë¬¸ì„ ììœ ë¡­ê²Œ ì…ë ¥í•´ë³´ì„¸ìš”!', 'info');
    </script>
</body>
</html>