<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOSTYPE BLE 테스트 (한글 지원)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 700px;
            text-align: center;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .status.disconnected { background: #fee; color: #c33; }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.connected { background: #d4edda; color: #155724; }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .typing-speed-control {
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .typing-speed-control label {
            color: #495057;
            font-weight: 500;
        }

        .typing-speed-control select {
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            color: #333;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .typing-speed-control select:hover {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .typing-speed-control select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.2);
        }

        .message-area {
            margin: 20px 0;
        }

        input[type="text"], textarea {
            width: 85%;
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 1.1em;
            margin-right: 10px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-btn {
            padding: 12px 20px;
            font-size: 0.9em;
        }

        .conversion-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            text-align: left;
            min-height: 60px;
            transition: all 0.3s ease;
        }

        .conversion-preview.korean {
            border-color: #28a745;
            background: #d4edda;
        }

        .conversion-preview.english {
            border-color: #007bff;
            background: #d1ecf1;
        }

        .conversion-preview.mixed {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .protocol-info {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        /* Log Modal Styles */
        .log-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }

        .log-modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            animation: modalSlide 0.3s ease-out;
        }

        .log-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .log-modal-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .log-modal-close {
            background: #dc3545;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .log-modal-close:hover {
            background: #c82333;
            transform: rotate(90deg);
        }

        .log-modal-body {
            flex: 1;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .view-logs-btn {
            background: linear-gradient(45deg, #17a2b8, #20c997);
            padding: 10px 20px;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .view-logs-btn:hover {
            background: linear-gradient(45deg, #138496, #1aa379);
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
        }

        .log-info { background: #d1ecf1; color: #0c5460; }
        .log-success { background: #d4edda; color: #155724; }
        .log-error { background: #f8d7da; color: #721c24; }
        .log-data { background: #fff3cd; color: #856404; }

        .test-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .test-btn {
            padding: 8px 16px;
            font-size: 0.9em;
            border-radius: 20px;
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .test-btn:hover {
            background: linear-gradient(45deg, #218838, #1ea383);
        }

        .korean-test-btn {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
        }

        .korean-test-btn:hover {
            background: linear-gradient(45deg, #c82333, #d91a72);
        }

        .special-btn {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
        }

        .special-btn:hover {
            background: linear-gradient(45deg, #5a2d91, #d91a72);
        }


        /* 카운트다운 모달 스타일 */
        .countdown-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .countdown-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: modalSlide 0.3s ease-out;
        }

        .countdown-instruction {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .countdown-instruction p {
            margin: 10px 0;
            color: #555;
            line-height: 1.5;
        }

        .countdown-instruction strong {
            color: #333;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .countdown-number {
            font-size: 4em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
            text-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .countdown-message {
            font-size: 1.2em;
            color: #333;
            margin: 20px 0;
        }

        .countdown-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            color: #495057;
            word-break: break-all;
            text-align: left;
        }

        .cancel-btn {
            background: #dc3545;
            margin-top: 20px;
        }

        .cancel-btn:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .info-box {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: left;
        }

        .info-box h4 {
            color: #004085;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .language-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 8px;
        }

        .lang-korean {
            background: #d4edda;
            color: #155724;
        }

        .lang-english {
            background: #d1ecf1;
            color: #0c5460;
        }

        .lang-mixed {
            background: #fff3cd;
            color: #856404;
        }

        .lang-special {
            background: #e2e3e5;
            color: #383d41;
        }

        /* Message Input Modal Styles */
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            backdrop-filter: blur(5px);
        }

        .message-modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            animation: modalSlide 0.3s ease-out;
        }

        .message-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .message-modal-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
        }

        .message-modal-textarea {
            width: 100%;
            min-height: 300px;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 15px;
            font-size: 1.2em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            margin-bottom: 20px;
        }

        .message-modal-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .message-modal-preview {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            max-height: 200px;
            overflow-y: auto;
        }

        .message-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .done-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .done-btn:hover {
            background: linear-gradient(45deg, #218838, #1aa383);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                width: 95%;
                padding: 20px;
            }

            .logo {
                font-size: 2em;
            }

            .subtitle {
                font-size: 1em;
            }

            button {
                padding: 12px 20px;
                font-size: 1em;
                min-width: 100px;
            }

            input[type="text"] {
                width: 100%;
                margin-bottom: 10px;
                margin-right: 0;
            }

            .message-area {
                display: flex;
                flex-direction: column;
            }

            .send-btn {
                width: 100%;
            }

            .test-buttons {
                gap: 5px;
            }

            .test-btn, .korean-test-btn, .special-btn {
                padding: 6px 12px;
                font-size: 0.8em;
            }

            .message-modal-content {
                padding: 20px;
                width: 95%;
            }

            .message-modal-textarea {
                min-height: 200px;
                font-size: 1em;
            }

            .log-modal-content {
                padding: 20px;
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <div class="container" role="main">
        <div class="logo">👻 GHOSTYPE</div>
        <div class="subtitle">BLE 키보드 웹 테스트 (한글 지원)</div>

        <div id="status" class="status disconnected" role="status" aria-live="polite">
            🔴 연결 안됨 - 연결 버튼을 클릭하세요
        </div>

        <div class="controls" role="group" aria-label="연결 컨트롤">
            <button id="connectBtn" onclick="connectDevice()" aria-label="BLE 디바이스 연결">🔗 연결</button>
            <button id="disconnectBtn" onclick="disconnectDevice()" disabled aria-label="BLE 디바이스 연결 해제">❌ 연결 해제</button>
            <button class="view-logs-btn" onclick="toggleLogModal()" aria-label="연결 로그 보기">📋 View Logs</button>
            <button class="view-logs-btn" onclick="openHistoryModal()" aria-label="메시지 히스토리 보기">📜 View History</button>
        </div>

        <!-- 타이핑 속도 설정 -->
        <div class="typing-speed-control" role="group" aria-label="타이핑 속도 설정">
            <label for="typingSpeed">⚡ Typing Speed (chars/sec):</label>
            <select id="typingSpeed" onchange="updateTypingSpeed()" aria-label="타이핑 속도 선택">
                <option value="13">13 (Slow)</option>
                <option value="15" selected>15 (Normal)</option>
                <option value="18">18 (Fast)</option>
                <option value="20">20 (Very Fast)</option>
                <option value="25">25 (Ultra Fast)</option>
                <option value="30">30 (Max Speed)</option>
            </select>
        </div>

        <div class="message-area">
            <textarea id="messageInput" placeholder="한글/영문 메시지를 입력하세요..." onclick="openMessageModal()" aria-label="메시지 입력" rows="1" style="resize: vertical; min-height: 48px; max-height: 120px; overflow-y: auto;"></textarea>
            <button class="send-btn" id="sendBtn" onclick="startCountdown()" disabled aria-label="메시지 전송">📤 전송</button>
        </div>

        <!-- 변환 미리보기 -->
        <div class="conversion-preview" id="conversionPreview" role="region" aria-label="텍스트 변환 미리보기" aria-live="polite">
            <strong>🔄 변환 미리보기:</strong><br>
            <span id="previewText">메시지를 입력하면 변환 결과가 여기에 표시됩니다</span>
            <div class="protocol-info" id="protocolInfo"></div>
        </div>


        <!-- 카운트다운 모달 -->
        <div id="countdownModal" class="countdown-modal" style="display: none;">
            <div class="countdown-content">
                <h3>⌨️ 키보드 입력 준비</h3>
                <div class="countdown-number" id="countdownNumber">5</div>
                <div class="countdown-message" id="countdownMessage">메모장에 커서를 놓고 기다리세요...</div>
                <div class="countdown-instruction">
                    <p>📝 <strong>중요:</strong> 입력을 받을 화면(메모장, 텍스트 에디터 등)에 커서를 클릭해 두세요!</p>
                    <p>⏰ 곧 자동 타이핑이 시작됩니다.</p>
                </div>
                <button class="cancel-btn" onclick="cancelCountdown()">❌ 취소</button>
            </div>
        </div>

        <!-- Log Modal -->
        <div id="logModal" class="log-modal" style="display: none;" role="dialog" aria-labelledby="logModalTitle" aria-describedby="logModalBody">
            <div class="log-modal-content">
                <div class="log-modal-header">
                    <h3 class="log-modal-title" id="logModalTitle">📋 Connection Logs</h3>
                    <button class="log-modal-close" onclick="toggleLogModal()" aria-label="로그 모달 닫기">×</button>
                </div>
                <div class="log-modal-body" id="logModalBody" role="log" aria-live="polite">
                    <div class="log-entry log-info">🌐 Web Bluetooth 준비됨 (한글 자모 변환 지원)</div>
                </div>
            </div>
        </div>

        <!-- Message Input Modal -->
        <div id="messageModal" class="message-modal" style="display: none;" role="dialog" aria-labelledby="messageModalTitle">
            <div class="message-modal-content">
                <div class="message-modal-header">
                    <h3 class="message-modal-title" id="messageModalTitle">✍️ Message Editor</h3>
                </div>
                <textarea 
                    id="messageModalTextarea" 
                    class="message-modal-textarea" 
                    placeholder="한글/영문 메시지를 입력하세요..."
                    aria-label="확장된 메시지 입력 영역"
                ></textarea>
                <div class="message-modal-preview" id="messageModalPreview">
                    <strong>🔄 변환 미리보기:</strong><br>
                    <span id="modalPreviewText">메시지를 입력하면 변환 결과가 여기에 표시됩니다</span>
                    <div class="protocol-info" id="modalProtocolInfo"></div>
                </div>
                <div class="message-modal-footer">
                    <button class="cancel-btn" onclick="closeMessageModal()" aria-label="취소">❌ Cancel</button>
                    <button class="done-btn" onclick="applyMessageModal()" aria-label="적용">✓ Done</button>
                </div>
            </div>
        </div>

        <!-- History Modal -->
        <div id="historyModal" class="history-modal" style="display: none;" role="dialog" aria-labelledby="historyModalTitle">
            <div class="history-modal-content">
                <div class="history-modal-header">
                    <h3 class="history-modal-title" id="historyModalTitle">📜 Message History</h3>
                    <button class="history-modal-close" onclick="closeHistoryModal()" aria-label="히스토리 모달 닫기">×</button>
                </div>
                
                <input type="text" id="historySearch" class="history-search" placeholder="Search messages..." aria-label="메시지 검색">
                
                <div class="history-stats" id="historyStats">
                    <span>Total: 0</span>
                    <span>Today: 0</span>
                    <span>This Week: 0</span>
                </div>
                
                <div class="history-list" id="historyList">
                    <div class="history-empty">No messages found. Start typing to build your history!</div>
                </div>
                
                <div class="history-modal-footer">
                    <button class="history-clear-btn" onclick="clearHistory()" aria-label="히스토리 삭제">🗑️ Clear All</button>
                    <button class="history-export-btn" onclick="exportHistory()" aria-label="히스토리 내보내기">📁 Export</button>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h4>📋 사용 방법:</h4>
            <ul>
                <li><strong>Chrome/Edge 브라우저</strong>에서만 동작합니다</li>
                <li>연결 버튼을 누르고 <strong>"GHOSTYPE-6FED"</strong> 선택</li>
                <li><strong>한글/영문/혼합 텍스트</strong> 모두 지원됩니다</li>
                <li>한글은 자동으로 <strong>자모 키 조합</strong>으로 변환됩니다</li>
                <li>입력 전 <strong>5초 카운트다운</strong>으로 안전하게 전송</li>
                <li>메모장을 열어두고 테스트해보세요!</li>
            </ul>
        </div>

        <div class="footer">
            💡 한글 지원: ㄱ-ㅎ, ㅏ-ㅣ 자모를 QWERTY 키로 자동 변환
        </div>
    </div>

    <script>
        // BLE 서비스 및 특성 UUID
        const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
        const RX_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
        const TX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

        let device = null;
        let server = null;
        let service = null;
        let rxCharacteristic = null;
        let txCharacteristic = null;
        let countdownTimer = null;
        let countdownPending = null;
        let currentTypingSpeed = 15; // Default typing speed in characters per second

        // ===== 한글 → 자모 키 변환 로직 =====

        // 두벌식 키보드 매핑 테이블
        const QWERTY_TO_JAMO = {
            // 자음 (왼손)
            'q': 'ㅂ', 'w': 'ㅈ', 'e': 'ㄷ', 'r': 'ㄱ', 't': 'ㅅ',
            'a': 'ㅁ', 's': 'ㄴ', 'd': 'ㅇ', 'f': 'ㄹ', 'g': 'ㅎ',
            'z': 'ㅋ', 'x': 'ㅌ', 'c': 'ㅊ', 'v': 'ㅍ',
            
            // 모음 (오른손)
            'y': 'ㅛ', 'u': 'ㅕ', 'i': 'ㅑ', 'o': 'ㅐ', 'p': 'ㅔ',
            'h': 'ㅗ', 'j': 'ㅓ', 'k': 'ㅏ', 'l': 'ㅣ',
            'b': 'ㅠ', 'n': 'ㅜ', 'm': 'ㅡ',
            
            // Shift 조합
            'Q': 'ㅃ', 'W': 'ㅉ', 'E': 'ㄸ', 'R': 'ㄲ', 'T': 'ㅆ',
            'O': 'ㅒ', 'P': 'ㅖ'
        };

        // 역방향 매핑 (자모 → QWERTY)
        const JAMO_TO_QWERTY = {};
        Object.keys(QWERTY_TO_JAMO).forEach(key => {
            JAMO_TO_QWERTY[QWERTY_TO_JAMO[key]] = key;
        });

        // 복합 모음 분해 매핑
        const COMPOUND_VOWELS = {
            'ㅘ': ['ㅗ', 'ㅏ'],  // o + a
            'ㅙ': ['ㅗ', 'ㅐ'],  // o + ae
            'ㅚ': ['ㅗ', 'ㅣ'],  // o + i
            'ㅝ': ['ㅜ', 'ㅓ'],  // u + eo
            'ㅞ': ['ㅜ', 'ㅔ'],  // u + e
            'ㅟ': ['ㅜ', 'ㅣ'],  // u + i
            'ㅢ': ['ㅡ', 'ㅣ']   // eu + i
        };

        // 한글 유니코드 분해 함수
        function decomposeHangul(char) {
            const code = char.charCodeAt(0);
            
            // 한글 완성형 범위 체크 (가-힣)
            if (code < 0xAC00 || code > 0xD7A3) {
                return null;
            }
            
            const base = code - 0xAC00;
            const cho = Math.floor(base / 588);           // 초성
            const jung = Math.floor((base % 588) / 28);   // 중성
            const jong = base % 28;                       // 종성
            
            // 자모 배열
            const chosung = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
            const jungsung = ['ㅏ','ㅐ','ㅑ','ㅒ','ㅓ','ㅔ','ㅕ','ㅖ','ㅗ','ㅘ','ㅙ','ㅚ','ㅛ','ㅜ','ㅝ','ㅞ','ㅟ','ㅠ','ㅡ','ㅢ','ㅣ'];
            const jongsung = ['','ㄱ','ㄲ','ㄱㅅ','ㄴ','ㄴㅈ','ㄴㅎ','ㄷ','ㄹ','ㄹㄱ','ㄹㅁ','ㄹㅂ','ㄹㅅ','ㄹㅌ','ㄹㅍ','ㄹㅎ','ㅁ','ㅂ','ㅂㅅ','ㅅ','ㅆ','ㅇ','ㅈ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
            
            const result = [];
            
            // 초성 추가
            result.push(chosung[cho]);
            
            // 중성 추가 (복합모음 처리)
            const jungsungChar = jungsung[jung];
            if (COMPOUND_VOWELS[jungsungChar]) {
                // 복합모음인 경우 분해해서 추가
                result.push(...COMPOUND_VOWELS[jungsungChar]);
            } else {
                // 단순모음인 경우 그대로 추가
                result.push(jungsungChar);
            }
            
            // 종성 추가 (복합자음 처리)
            if (jong > 0) {
                const jongChar = jongsung[jong];
                if (jongChar.length === 2) {
                    // 복합 종성 (예: ㄱㅅ)
                    result.push(jongChar[0]);
                    result.push(jongChar[1]);
                } else {
                    result.push(jongChar);
                }
            }
            
            return result;
        }

        // 자모를 QWERTY 키로 변환
        function jamoToQwerty(jamo) {
            // Check if the character exists in the mapping
            if (JAMO_TO_QWERTY.hasOwnProperty(jamo)) {
                return JAMO_TO_QWERTY[jamo];
            }
            
            // For unmapped characters, only return if it's a safe printable character
            const code = jamo.charCodeAt(0);
            if ((code >= 32 && code <= 126) || (code >= 0xAC00 && code <= 0xD7A3)) {
                return jamo;
            }
            
            // Filter out problematic characters that might cause issues
            return '';
        }

        // 한글 텍스트를 자모 키 조합으로 변환
        function convertHangulToJamoKeys(text) {
            let result = '';
            
            for (let char of text) {
                const jamos = decomposeHangul(char);
                if (jamos) {
                    // 한글인 경우 자모로 분해 후 QWERTY 키로 변환
                    for (let jamo of jamos) {
                        const qwertyKey = jamoToQwerty(jamo);
                        if (qwertyKey) {
                            result += qwertyKey;
                        } else {
                            console.warn('매핑되지 않은 자모:', jamo, '(U+' + jamo.charCodeAt(0).toString(16).toUpperCase() + ')');
                        }
                    }
                } else {
                    // Check if it's a single jamo character (ㅂㅈㄷㄱ 등)
                    const qwertyKey = jamoToQwerty(char);
                    if (qwertyKey) {
                        result += qwertyKey;
                    } else {
                        // 한글이 아닌 경우 그대로
                        result += char;
                    }
                }
            }
            
            return result;
        }

        // 텍스트 타입 분석
        function analyzeText(text) {
            let hasKorean = false;
            let hasEnglish = false;
            let hasSpecial = false;
            
            for (let char of text) {
                const code = char.charCodeAt(0);
                if (code >= 0xAC00 && code <= 0xD7A3) {
                    hasKorean = true;
                } else if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) {
                    hasEnglish = true;
                } else if (code >= 32 && code <= 126) {
                    hasSpecial = true;
                }
            }
            
            if (hasKorean && hasEnglish) return 'mixed';
            if (hasKorean) return 'korean';
            if (hasEnglish || hasSpecial) return 'english';
            return 'unknown';
        }

        // 스마트 텍스트 변환 (프로토콜 포함)
        function convertTextWithProtocol(text) {
            console.log('convertTextWithProtocol 시작, 입력:', JSON.stringify(text));
            console.log('입력에 엔터키 있나?', text.includes('\n'));
            
            const type = analyzeText(text);
            console.log('analyzeText 결과:', type);
            
            if (type === 'korean' || type === 'mixed') {
                // 한글이 포함된 경우: 자모 키로 변환 후 JSON 형태로 전송
                const jamoKeys = convertHangulToJamoKeys(text);
                console.log('jamoKeys 변환 결과:', JSON.stringify(jamoKeys));
                console.log('변환 후 엔터키 있나?', jamoKeys.includes('\n'));
                
                const jsonData = {
                    text: jamoKeys,
                    speed_cps: currentTypingSpeed,
                    type: 'korean'
                };
                console.log('한글 JSON 생성:', jsonData);
                console.log('현재 타이핑 속도:', currentTypingSpeed);
                
                const result = {
                    original: text,
                    converted: jamoKeys,
                    protocol: JSON.stringify(jsonData),
                    type: type,
                    description: '한글 자모 키 변환'
                };
                console.log('최종 프로토콜:', JSON.stringify(result.protocol));
                console.log('포함된 타이핑 속도:', currentTypingSpeed);
                return result;
            } else {
                // 순수 영문인 경우: JSON 형태로 전송
                console.log('영문 처리 - 원본 그대로');
                
                const jsonData = {
                    text: text,
                    speed_cps: currentTypingSpeed,
                    type: 'english'
                };
                console.log('영문 JSON 생성:', jsonData);
                console.log('현재 타이핑 속도:', currentTypingSpeed);
                
                const result = {
                    original: text,
                    converted: text,
                    protocol: JSON.stringify(jsonData),
                    type: 'english',
                    description: '영문 직접 입력'
                };
                console.log('최종 프로토콜:', JSON.stringify(result.protocol));
                console.log('포함된 타이핑 속도:', currentTypingSpeed);
                return result;
            }
        }

        // 실시간 변환 미리보기 업데이트
        // 긴 텍스트 축약 함수
        function truncateText(text, maxLength = 100) {
            if (!text || text.length <= maxLength) {
                return text;
            }
            return text.substring(0, maxLength) + '...';
        }

        function updateConversionPreview() {
            const input = document.getElementById('messageInput');
            const preview = document.getElementById('conversionPreview');
            const previewText = document.getElementById('previewText');
            const protocolInfo = document.getElementById('protocolInfo');
            const text = input.value;
            
            // 디버깅: 미리보기 업데이트 시 텍스트 확인
            console.log('updateConversionPreview 호출, 텍스트:', JSON.stringify(text));
            console.log('미리보기 텍스트에 엔터키 있나?', text.includes('\n'));
            
            if (!text) {
                preview.className = 'conversion-preview';
                previewText.textContent = '메시지를 입력하면 변환 결과가 여기에 표시됩니다';
                protocolInfo.textContent = '';
                return;
            }
            
            const result = convertTextWithProtocol(text);
            
            // 미리보기 스타일 업데이트
            preview.className = `conversion-preview ${result.type}`;
            
            // 긴 텍스트 축약
            const truncatedOriginal = truncateText(result.original, 50);
            const truncatedConverted = truncateText(result.converted, 50);
            
            // 엔터키 등 특수 문자 표시
            const displayOriginal = truncatedOriginal
                .replace(/\n/g, '↵<br>')
                .replace(/\t/g, '→')
                .replace(/\r/g, '↓');
            
            const displayConverted = truncatedConverted
                .replace(/\n/g, '↵<br>')
                .replace(/\t/g, '→')
                .replace(/\r/g, '↓');
            
            // 변환 결과 표시
            if (result.type === 'korean' || result.type === 'mixed') {
                previewText.innerHTML = `
                    <strong>원본:</strong> ${displayOriginal}<br>
                    <strong>자모:</strong> ${displayConverted}<br>
                    <strong>설명:</strong> ${result.description}
                `;
            } else {
                previewText.innerHTML = `
                    <strong>텍스트:</strong> ${displayOriginal}<br>
                    <strong>설명:</strong> ${result.description}
                `;
            }
            
            // 프로토콜 정보도 축약
            const truncatedProtocol = truncateText(result.protocol, 80);
            protocolInfo.textContent = `전송 프로토콜: ${truncatedProtocol}`;
        }

        // ===== BLE 통신 함수들 =====

        function addLog(message, type = 'info') {
            const log = document.getElementById('logModalBody');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function toggleLogModal() {
            const modal = document.getElementById('logModal');
            modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
        }

        // Close modals when clicking outside
        document.getElementById('logModal').addEventListener('click', function(event) {
            if (event.target === this) {
                toggleLogModal();
            }
        });

        document.getElementById('messageModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeMessageModal();
            }
        });

        document.getElementById('countdownModal').addEventListener('click', function(event) {
            if (event.target === this) {
                cancelCountdown();
            }
        });

        // Typing Speed Control
        function updateTypingSpeed() {
            const speedSelect = document.getElementById('typingSpeed');
            const newSpeed = parseInt(speedSelect.value);
            
            console.log('타이핑 속도 변경:', currentTypingSpeed, '→', newSpeed);
            currentTypingSpeed = newSpeed;
            
            // Save to localStorage
            localStorage.setItem('ghostype_typing_speed', currentTypingSpeed);
            
            // Send configuration to ESP32 if connected
            if (rxCharacteristic) {
                const configData = {
                    mode: "typing",
                    speed_cps: currentTypingSpeed
                };
                const configProtocol = `GHTYPE_CFG:${JSON.stringify(configData)}`;
                
                console.log('속도 설정 전송:', configProtocol);
                
                sendData(configProtocol).then(success => {
                    if (success) {
                        addLog(`⚡ 타이핑 속도 변경: ${currentTypingSpeed} chars/sec`, 'success');
                    }
                });
            } else {
                addLog(`⚡ 타이핑 속도 설정: ${currentTypingSpeed} chars/sec (연결 후 적용)`, 'info');
            }
        }

        // Load saved typing speed
        function loadTypingSpeed() {
            const savedSpeed = localStorage.getItem('ghostype_typing_speed');
            if (savedSpeed) {
                currentTypingSpeed = parseInt(savedSpeed);
                document.getElementById('typingSpeed').value = savedSpeed;
            }
        }

        // Message Modal Functions
        function openMessageModal() {
            const modal = document.getElementById('messageModal');
            const textarea = document.getElementById('messageModalTextarea');
            const input = document.getElementById('messageInput');
            
            // Copy current value to modal
            textarea.value = input.value;
            modal.style.display = 'flex';
            
            // Focus textarea and update preview
            textarea.focus();
            updateModalPreview();
        }

        function closeMessageModal() {
            const modal = document.getElementById('messageModal');
            modal.style.display = 'none';
        }

        function applyMessageModal() {
            const textarea = document.getElementById('messageModalTextarea');
            const input = document.getElementById('messageInput');
            
            // 디버깅: 텍스트가 제대로 복사되는지 확인
            console.log('팝업 텍스트:', JSON.stringify(textarea.value));
            console.log('팝업 텍스트에 엔터키 있나?', textarea.value.includes('\n'));
            
            // Copy value back to input
            input.value = textarea.value;
            
            console.log('메인 입력창 텍스트:', JSON.stringify(input.value));
            console.log('메인 입력창에 엔터키 있나?', input.value.includes('\n'));
            
            updateConversionPreview();
            closeMessageModal();
        }

        function updateModalPreview() {
            const textarea = document.getElementById('messageModalTextarea');
            const previewText = document.getElementById('modalPreviewText');
            const protocolInfo = document.getElementById('modalProtocolInfo');
            const text = textarea.value;
            
            if (!text) {
                previewText.textContent = '메시지를 입력하면 변환 결과가 여기에 표시됩니다';
                protocolInfo.textContent = '';
                return;
            }
            
            const result = convertTextWithProtocol(text);
            
            // 긴 텍스트 축약 (모달에서는 조금 더 길게)
            const truncatedOriginal = truncateText(result.original, 80);
            const truncatedConverted = truncateText(result.converted, 80);
            
            // 엔터키 등 특수 문자 표시
            const displayOriginal = truncatedOriginal
                .replace(/\n/g, '↵<br>')
                .replace(/\t/g, '→')
                .replace(/\r/g, '↓');
            
            const displayConverted = truncatedConverted
                .replace(/\n/g, '↵<br>')
                .replace(/\t/g, '→')
                .replace(/\r/g, '↓');
            
            if (result.type === 'korean' || result.type === 'mixed') {
                previewText.innerHTML = `
                    <strong>원본:</strong> ${displayOriginal}<br>
                    <strong>자모:</strong> ${displayConverted}<br>
                    <strong>설명:</strong> ${result.description}
                `;
            } else {
                previewText.innerHTML = `
                    <strong>텍스트:</strong> ${displayOriginal}<br>
                    <strong>설명:</strong> ${result.description}
                `;
            }
            
            // 프로토콜 정보도 축약
            const truncatedProtocol = truncateText(result.protocol, 100);
            protocolInfo.textContent = `전송 프로토콜: ${truncatedProtocol}`;
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function updateUI(connected) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            // 입력창은 항상 활성화 (미리보기를 위해)
            // document.getElementById('messageInput').disabled = !connected;
            document.getElementById('sendBtn').disabled = !connected;
            
            if (connected) {
                addLog('🇰🇷 한글 자모 변환 기능 활성화', 'info');
                addLog('⌨️ 모든 한글이 자동으로 자모 키로 변환됩니다', 'info');
            }
        }

        // 카운트다운 시작
        function startCountdown() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) {
                addLog('⚠️ 메시지를 입력하세요', 'error');
                return;
            }

            if (!rxCharacteristic) {
                addLog('❌ 먼저 GHOSTYPE 디바이스에 연결하세요', 'error');
                return;
            }

            const result = convertTextWithProtocol(message);
            startCountdownWithResult(result, () => {
                sendData(result.protocol);
                input.value = '';
                updateConversionPreview();
            });
        }

        // 테스트 텍스트 전송
        function testText(text) {
            const result = convertTextWithProtocol(text);
            startCountdownWithResult(result, () => {
                sendData(result.protocol);
            });
        }

        // 특수 키 전송
        function testSpecial(command) {
            const protocol = `GHTYPE_SPE:${command}`;
            const result = {
                original: command,
                converted: command,
                protocol: protocol,
                type: 'special',
                description: '특수 키 명령'
            };
            
            startCountdownWithResult(result, () => {
                sendData(protocol);
            });
        }

        // 카운트다운 (변환 결과 포함)
        function startCountdownWithResult(result, callback) {
            if (!rxCharacteristic) {
                addLog('❌ 연결되지 않음', 'error');
                return;
            }

            const modal = document.getElementById('countdownModal');
            const numberEl = document.getElementById('countdownNumber');
            const messageEl = document.getElementById('countdownMessage');
            
            modal.style.display = 'flex';
            
            let count = 5;
            countdownPending = callback;
            
            function updateCountdown() {
                numberEl.textContent = count;
                
                if (count > 0) {
                    messageEl.textContent = `${count}초 후 입력이 시작됩니다...`;
                    count--;
                    countdownTimer = setTimeout(updateCountdown, 1000);
                } else {
                    messageEl.textContent = '입력 중... ⌨️';
                    numberEl.textContent = '⌨️';
                    numberEl.style.animation = 'none';
                    
                    setTimeout(() => {
                        modal.style.display = 'none';
                        if (countdownPending) {
                            countdownPending();
                            countdownPending = null;
                            addLog(`⌨️ 전송: ${result.description} - "${result.original}"`, 'success');
                        }
                        numberEl.style.animation = 'pulse 1s ease-in-out infinite';
                    }, 1000);
                }
            }
            
            updateCountdown();
            addLog(`⏰ 5초 카운트다운: ${result.description}`, 'info');
        }

        function cancelCountdown() {
            if (countdownTimer) {
                clearTimeout(countdownTimer);
                countdownTimer = null;
            }
            countdownPending = null;
            
            const modal = document.getElementById('countdownModal');
            modal.style.display = 'none';
            
            addLog('❌ 입력 취소됨', 'info');
        }

        // BLE 연결
        async function connectDevice() {
            try {
                addLog('🔍 GHOSTYPE 디바이스 검색 중...', 'info');
                updateStatus('🔍 디바이스 검색 중...', 'connecting');

                device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'GHOSTYPE' },
                        { services: [SERVICE_UUID] }
                    ],
                    optionalServices: [SERVICE_UUID]
                });

                addLog(`📱 디바이스 발견: ${device.name}`, 'success');
                device.addEventListener('gattserverdisconnected', onDisconnected);

                addLog('🔗 GATT 서버 연결 중...', 'info');
                server = await device.gatt.connect();

                addLog('📡 Nordic UART 서비스 검색 중...', 'info');
                service = await server.getPrimaryService(SERVICE_UUID);

                addLog('🔧 특성 설정 중...', 'info');
                rxCharacteristic = await service.getCharacteristic(RX_CHAR_UUID);
                txCharacteristic = await service.getCharacteristic(TX_CHAR_UUID);

                await txCharacteristic.startNotifications();
                txCharacteristic.addEventListener('characteristicvaluechanged', onDataReceived);

                addLog('🎉 연결 완료! 한글/영문 모두 지원됩니다', 'success');
                updateStatus('🟢 연결됨 - 한글/영문 입력 가능', 'connected');
                updateUI(true);

                // 자동 전송 제거됨 - 사용자가 필요할 때만 수동으로 전송

            } catch (error) {
                addLog(`❌ 연결 실패: ${error.message}`, 'error');
                updateStatus('🔴 연결 실패', 'disconnected');
                console.error('Connection failed:', error);
            }
        }

        function onDataReceived(event) {
            const value = new TextDecoder().decode(event.target.value);
            addLog(`📨 ESP32 응답: "${value}"`, 'data');
        }

        function onDisconnected() {
            addLog('👋 디바이스 연결 해제됨', 'info');
            updateStatus('🔴 연결 해제됨', 'disconnected');
            updateUI(false);
            
            device = null;
            server = null;
            service = null;
            rxCharacteristic = null;
            txCharacteristic = null;
        }

        async function disconnectDevice() {
            if (device && device.gatt.connected) {
                await device.gatt.disconnect();
            }
        }

        // BLE 연결 상태 진단 함수
        function diagnoseBLEConnection() {
            console.log('=== BLE 연결 진단 ===');
            console.log('device:', device);
            console.log('device.gatt:', device ? device.gatt : 'device is null');
            console.log('device.gatt.connected:', device && device.gatt ? device.gatt.connected : 'gatt is null');
            console.log('server:', server);
            console.log('service:', service);
            console.log('rxCharacteristic:', rxCharacteristic);
            console.log('txCharacteristic:', txCharacteristic);
            
            if (device && device.gatt) {
                addLog(`🔍 BLE 연결 상태: ${device.gatt.connected ? '연결됨' : '연결 끊김'}`, 'info');
            } else {
                addLog('🔍 BLE 디바이스 객체가 없음', 'error');
            }
        }

        async function sendData(message) {
            if (!rxCharacteristic) {
                addLog('❌ 연결되지 않음', 'error');
                diagnoseBLEConnection();
                return false;
            }

            // BLE 연결 상태 확인
            if (!device || !device.gatt.connected) {
                addLog('❌ BLE 연결이 끊어졌습니다', 'error');
                diagnoseBLEConnection();
                return false;
            }

            console.log('sendData 호출, 메시지:', JSON.stringify(message));
            console.log('전송할 메시지에 엔터키 있나?', message.includes('\n'));

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                
                console.log('인코딩된 데이터 길이:', data.length);
                
                // BLE writeValue는 512바이트로 제한됨 - 청크로 분할 전송
                const MAX_CHUNK_SIZE = 500; // 안전마진을 위해 500바이트로 제한
                
                if (data.length > 10000) {
                    addLog(`⚠️ 텍스트가 너무 깁니다 (${data.length}바이트). 10KB 이하로 줄여주세요.`, 'error');
                    return false;
                }
                
                if (data.length <= MAX_CHUNK_SIZE) {
                    // 작은 데이터는 한 번에 전송 (재시도 로직 포함)
                    let retryCount = 0;
                    const maxRetries = 3;
                    
                    while (retryCount < maxRetries) {
                        try {
                            // 연결 상태 및 특성 유효성 체크
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE 연결이 끊어졌습니다');
                            }
                            
                            await rxCharacteristic.writeValue(data);
                            addLog(`📤 프로토콜 전송 (${data.length}바이트): "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`, 'success');
                            break; // 성공시 루프 종료
                        } catch (simpleError) {
                            retryCount++;
                            console.warn(`단순 전송 실패 (${retryCount}/${maxRetries}):`, simpleError.message);
                            
                            // 특정 에러 타입 체크
                            if (simpleError.message.includes('GATT operation failed') || 
                                simpleError.message.includes('Cannot read properties of null')) {
                                addLog(`⚠️ BLE 연결 불안정 감지 (단순 전송): ${simpleError.message}`, 'warning');
                                
                                // 연결 상태 재확인
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE 연결이 끊어져서 전송 중단됨');
                                }
                            }
                            
                            if (retryCount >= maxRetries) {
                                throw new Error(`단순 전송 실패: ${simpleError.message}`);
                            }
                            
                            // 재시도 전 연결 상태 재확인
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE 연결이 끊어져서 재시도 불가능');
                            }
                            
                            // 재시도 전 딜레이 (에러 타입에 따라 조정)
                            const delayMs = simpleError.message.includes('GATT operation failed') ? 1000 : 500;
                            await new Promise(resolve => setTimeout(resolve, delayMs));
                        }
                    }
                } else {
                    // 큰 데이터는 청크로 분할 전송
                    const totalChunks = Math.ceil(data.length / MAX_CHUNK_SIZE);
                    addLog(`📤 큰 데이터를 청크로 분할 전송 (총 ${data.length}바이트, ${totalChunks}개 청크)`, 'info');
                    
                    // 첫 번째 청크에 특별한 헤더 추가로 ESP32에게 분할 전송임을 알림
                    const firstChunkHeader = "CHUNK_START:";
                    const headerBytes = encoder.encode(firstChunkHeader);
                    
                    let chunkIndex = 0;
                    let dataOffset = 0;
                    
                    while (dataOffset < data.length) {
                        let chunk;
                        
                        if (chunkIndex === 0) {
                            // 첫 번째 청크: 헤더 + 데이터
                            const availableSpace = MAX_CHUNK_SIZE - headerBytes.length;
                            const dataChunk = data.slice(dataOffset, dataOffset + availableSpace);
                            chunk = new Uint8Array(headerBytes.length + dataChunk.length);
                            chunk.set(headerBytes, 0);
                            chunk.set(dataChunk, headerBytes.length);
                            dataOffset += availableSpace;
                        } else {
                            // 이후 청크들: 데이터만
                            const dataChunk = data.slice(dataOffset, dataOffset + MAX_CHUNK_SIZE);
                            chunk = dataChunk;
                            dataOffset += MAX_CHUNK_SIZE;
                        }
                        
                        // 청크 전송 재시도 로직
                        let retryCount = 0;
                        const maxRetries = 3;
                        
                        while (retryCount < maxRetries) {
                            try {
                                // 연결 상태 및 특성 유효성 체크
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE 연결이 끊어졌습니다');
                                }
                                
                                await rxCharacteristic.writeValue(chunk);
                                
                                // 진행 상황 표시
                                const progress = Math.round((chunkIndex + 1) / totalChunks * 100);
                                console.log(`청크 ${chunkIndex + 1}/${totalChunks} 전송 (${progress}%): ${chunk.length}바이트`);
                                addLog(`📤 청크 ${chunkIndex + 1}/${totalChunks} 전송 완료 (${progress}%)`, 'info');
                                
                                break; // 성공시 루프 종료
                            } catch (chunkError) {
                                retryCount++;
                                console.warn(`청크 ${chunkIndex + 1} 전송 실패 (${retryCount}/${maxRetries}):`, chunkError.message);
                                
                                // 특정 에러 타입 체크
                                if (chunkError.message.includes('GATT operation failed') || 
                                    chunkError.message.includes('Cannot read properties of null')) {
                                    addLog(`⚠️ BLE 연결 불안정 감지 (청크 ${chunkIndex + 1}): ${chunkError.message}`, 'warning');
                                    
                                    // 연결 상태 재확인
                                    if (!rxCharacteristic || !device || !device.gatt.connected) {
                                        throw new Error('BLE 연결이 끊어져서 전송 중단됨');
                                    }
                                }
                                
                                if (retryCount >= maxRetries) {
                                    throw new Error(`청크 ${chunkIndex + 1} 전송 실패: ${chunkError.message}`);
                                }
                                
                                // 재시도 전 연결 상태 재확인
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE 연결이 끊어져서 재시도 불가능');
                                }
                                
                                // 재시도 전 더 긴 딜레이 (에러 타입에 따라 조정)
                                const delayMs = chunkError.message.includes('GATT operation failed') ? 1000 : 500;
                                await new Promise(resolve => setTimeout(resolve, delayMs));
                            }
                        }
                        
                        chunkIndex++;
                        
                        // 청크 간 딜레이 증가 (BLE 안정성 향상)
                        await new Promise(resolve => setTimeout(resolve, 150));
                    }
                    
                    // 전송 완료 마커 (재시도 로직 포함)
                    const endMarker = encoder.encode("CHUNK_END");
                    let endMarkerRetryCount = 0;
                    const endMarkerMaxRetries = 3;
                    
                    while (endMarkerRetryCount < endMarkerMaxRetries) {
                        try {
                            // 연결 상태 및 특성 유효성 체크
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE 연결이 끊어졌습니다');
                            }
                            
                            await rxCharacteristic.writeValue(endMarker);
                            console.log('CHUNK_END 마커 전송 성공');
                            break;
                        } catch (endError) {
                            endMarkerRetryCount++;
                            console.warn(`CHUNK_END 마커 전송 실패 (${endMarkerRetryCount}/${endMarkerMaxRetries}):`, endError.message);
                            
                            // 특정 에러 타입 체크
                            if (endError.message.includes('GATT operation failed') || 
                                endError.message.includes('Cannot read properties of null')) {
                                addLog(`⚠️ BLE 연결 불안정 감지 (CHUNK_END): ${endError.message}`, 'warning');
                                
                                // 연결 상태 재확인
                                if (!rxCharacteristic || !device || !device.gatt.connected) {
                                    throw new Error('BLE 연결이 끊어져서 CHUNK_END 전송 중단됨');
                                }
                            }
                            
                            if (endMarkerRetryCount >= endMarkerMaxRetries) {
                                throw new Error(`CHUNK_END 마커 전송 실패: ${endError.message}`);
                            }
                            
                            // 재시도 전 연결 상태 재확인
                            if (!rxCharacteristic || !device || !device.gatt.connected) {
                                throw new Error('BLE 연결이 끊어져서 재시도 불가능');
                            }
                            
                            // 재시도 전 더 긴 딜레이 (에러 타입에 따라 조정)
                            const delayMs = endError.message.includes('GATT operation failed') ? 1000 : 500;
                            await new Promise(resolve => setTimeout(resolve, delayMs));
                        }
                    }
                    
                    addLog(`📤 분할 전송 완료: ${totalChunks}개 청크 (${data.length}바이트)`, 'success');
                }
                
                return true;
            } catch (error) {
                addLog(`❌ 전송 실패: ${error.message}`, 'error');
                console.error('전송 에러:', error);
                
                // 전송 실패 시 연결 상태 재진단
                diagnoseBLEConnection();
                
                // 에러 타입별 분석
                if (error.message.includes('GATT operation failed')) {
                    addLog('💡 GATT 작업 실패 - ESP32 응답 없음 또는 연결 불안정', 'warning');
                } else if (error.message.includes('Cannot read properties of null')) {
                    addLog('💡 특성 객체가 null - 연결이 예상보다 빨리 끊어짐', 'warning');
                } else if (error.message.includes('NetworkError')) {
                    addLog('💡 네트워크 오류 - 블루투스 하드웨어 문제 가능성', 'warning');
                }
                
                return false;
            }
        }

        // 이벤트 리스너
        document.getElementById('messageInput').addEventListener('input', function(event) {
            // 텍스트에리어 자동 크기 조정 (최대 120px)
            const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            
            updateConversionPreview();
        });
        
        document.getElementById('messageInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                startCountdown();
            }
            // Shift+Enter는 줄바꿈 허용
        });
        
        // Add paste event listener for main input field
        document.getElementById('messageInput').addEventListener('paste', function(event) {
            event.preventDefault();
            
            // Get clipboard data
            const clipboardData = event.clipboardData || window.clipboardData;
            let pastedText = clipboardData.getData('text');
            
            // Clean the pasted text to remove any problematic characters
            pastedText = pastedText.replace(/[^\x00-\x7F\uAC00-\uD7A3\u3130-\u318F]/g, '');
            
            // Insert the cleaned text at cursor position
            const input = event.target;
            const startPos = input.selectionStart;
            const endPos = input.selectionEnd;
            const textBefore = input.value.substring(0, startPos);
            const textAfter = input.value.substring(endPos);
            
            input.value = textBefore + pastedText + textAfter;
            
            // Set cursor position after pasted text
            const newCursorPos = startPos + pastedText.length;
            input.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update the preview
            updateConversionPreview();
        });

        // Message modal textarea event listener
        document.getElementById('messageModalTextarea').addEventListener('input', updateModalPreview);
        
        // Add paste event listener for proper clipboard handling
        document.getElementById('messageModalTextarea').addEventListener('paste', function(event) {
            event.preventDefault();
            
            // Get clipboard data
            const clipboardData = event.clipboardData || window.clipboardData;
            let pastedText = clipboardData.getData('text');
            
            // Clean the pasted text to remove any problematic characters
            pastedText = pastedText.replace(/[^\x00-\x7F\uAC00-\uD7A3\u3130-\u318F]/g, '');
            
            // Insert the cleaned text at cursor position
            const textarea = event.target;
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const textBefore = textarea.value.substring(0, startPos);
            const textAfter = textarea.value.substring(endPos);
            
            textarea.value = textBefore + pastedText + textAfter;
            
            // Set cursor position after pasted text
            const newCursorPos = startPos + pastedText.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update the preview
            updateModalPreview();
        });
        
        // Close modals on Escape key and handle keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                if (document.getElementById('logModal').style.display === 'flex') {
                    toggleLogModal();
                }
                if (document.getElementById('messageModal').style.display === 'flex') {
                    closeMessageModal();
                }
            }
            
            // Handle Ctrl+V / Cmd+V for paste operations
            if ((event.ctrlKey || event.metaKey) && event.key === 'v') {
                // Let the paste event handlers handle this
                // Don't prevent default here to allow normal paste behavior
            }
        });

        // Web Bluetooth 지원 확인
        if (!navigator.bluetooth) {
            addLog('❌ 이 브라우저는 Web Bluetooth를 지원하지 않습니다', 'error');
            updateStatus('🚫 Web Bluetooth 미지원', 'disconnected');
        }

        // 초기 상태
        updateUI(false);
        updateConversionPreview();
        loadTypingSpeed(); // Load saved typing speed
        addLog('💡 연결 후 한글/영문을 자유롭게 입력해보세요!', 'info');
    </script>
</body>
</html>